<html>
  <head><link rel="stylesheet" type="text/css" href="doxygen.css"></head>
  <body>
    <table width="100%" border="0" cellpadding="0" cellspacing="0">
        <tr> <td align=left style="background:#0F5286"> <img src="bwlogo_bluebkg.png"> </td> </tr>
    </table>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>Endpoint Class Reference<br>
<small>
[<a class="el" href="group__network.html">Network</a>]</small>
</h1><!-- doxytag: class="Endpoint" -->This class provides a wrapper around a socket.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;endpoint.hpp&gt;</code>
<p>
<a href="classEndpoint-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Network Interface Methods</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#ca294094f102a5f9c0ed81831b402325">getInterfaceFlags</a> (char *name, int &amp;flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the flags associated with the given interface.  <a href="#ca294094f102a5f9c0ed81831b402325"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#7434052e2d5f2eccd288fb5a5d7af994">getInterfaceAddress</a> (const char *name, <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> &amp;address)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the address to which an interface is bound.  <a href="#7434052e2d5f2eccd288fb5a5d7af994"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#8988f8fc548d19c73dafde09ea665c31">getInterfaceNetmask</a> (const char *name, <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> &amp;netmask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#92a10f1f19b22488ede5d6436cc7373c">getInterfaces</a> (std::map&lt; <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a>, std::string &gt; &amp;interfaces)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a address/name map of all network interfaces.  <a href="#92a10f1f19b22488ede5d6436cc7373c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#e6142dee4fac0a54a2e3333efb94d195">findDefaultInterface</a> (char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function finds the default interface, i.e.  <a href="#e6142dee4fac0a54a2e3333efb94d195"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#29837428a26dccaca740c4f83320d6c0">findIndicatedInterface</a> (const char *spec, char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function finds the interfaced specified by a string.  <a href="#29837428a26dccaca740c4f83320d6c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#509eb4888e5315e419260acf814232cb">convertAddress</a> (const char *string, <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> &amp;address)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method converts a string containing an IP address into a 32 integer in network byte order.  <a href="#509eb4888e5315e419260acf814232cb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction/Destruction</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#d4730afc3c8453cc37b3c9a7baa44156">Endpoint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the default constructor.  <a href="#d4730afc3c8453cc37b3c9a7baa44156"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#b64a9b395d12d536348ad05f795c88d8">~Endpoint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the destructor.  <a href="#b64a9b395d12d536348ad05f795c88d8"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">File descriptor access</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#46ce3c9f408f45959321af3ed4fa2837">operator int</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This operator returns the file descriptor for this endpoint.  <a href="#46ce3c9f408f45959321af3ed4fa2837"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#5f687f3f3844e99330cd7ed84fc33e90">setFileDescriptor</a> (int fd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets the file descriptor used by this endpoint.  <a href="#5f687f3f3844e99330cd7ed84fc33e90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#f4fa84c70d419d0c77d76cc6f0a9294f">good</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns true if this endpoint is a valid socket.  <a href="#f4fa84c70d419d0c77d76cc6f0a9294f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">General Socket Methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#cb67df89f00a53caefa74a27a698cc32">socket</a> (int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method creates a socket of the requested type.  <a href="#cb67df89f00a53caefa74a27a698cc32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#cf4bfc4ec6e73c14d880498433f8daf7">setnonblocking</a> (bool nonblocking)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method controls the blocking mode of the socket.  <a href="#cf4bfc4ec6e73c14d880498433f8daf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#5f84deda0721079d9fec7aa88ab20bfe">setbroadcast</a> (bool broadcast)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method toggles the broadcast mode of the socket.  <a href="#5f84deda0721079d9fec7aa88ab20bfe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#da50f9335e99f92f467169dae500e6d3">setreuseaddr</a> (bool reuseaddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method toggles the reuse address mode of the socket.  <a href="#da50f9335e99f92f467169dae500e6d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#43af92a5b5f1c3b279d3bfa342de7a46">setkeepalive</a> (bool keepalive)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#5a6977fce5e96295c8738c3ea930d083">bind</a> (<a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a> networkPort=0, <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> networkAddr=INADDR_ANY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method binds the socket to a given address and port.  <a href="#5a6977fce5e96295c8738c3ea930d083"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#483dd0b25562c8e49e1863e2a455abfa">joinMulticastGroup</a> (<a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> networkAddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method joins the socket up to the given multicast group.  <a href="#483dd0b25562c8e49e1863e2a455abfa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#78dbcd73aa7a4e1c57b6da6e49c71573">quitMulticastGroup</a> (<a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> networkAddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method gets the socket to quit the given multicast group.  <a href="#78dbcd73aa7a4e1c57b6da6e49c71573"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#09102067d11fc8a0e303d54dcbbf6c49">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method closes the socket associated with this endpoint.  <a href="#09102067d11fc8a0e303d54dcbbf6c49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#401a40954e086d5df4b5702625caecfd">detach</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method detaches the socket from this endpoint.  <a href="#401a40954e086d5df4b5702625caecfd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#2e2a986916866ca60468808f430c29af">getlocaladdress</a> (<a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a> *networkPort, <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> *networkAddr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the local address and port to which this endpoint is bound.  <a href="#2e2a986916866ca60468808f430c29af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#76593ac78ac0a6811e7f0e2446656522">getremoteaddress</a> (<a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a> *networkPort, <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> *networkAddr) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the remote address and port to which this endpoint is connected.  <a href="#76593ac78ac0a6811e7f0e2446656522"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classMercury_1_1Address.html">Mercury::Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#556fed718ea7392a0d29aab0d0fc5101">getLocalAddress</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the address that this endpoint is bound to.  <a href="#556fed718ea7392a0d29aab0d0fc5101"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classMercury_1_1Address.html">Mercury::Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#7022bd2868ba5581c9c838eb2dc05185">getRemoteAddress</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the address that this endpoint is bound to.  <a href="#7022bd2868ba5581c9c838eb2dc05185"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#403b88cdf7ea64c1888f99ab4d0a2556">c_str</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the string representation of the address this endpoint is bound to.  <a href="#403b88cdf7ea64c1888f99ab4d0a2556"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#6f9cc823f1a72f7d4e35bbc63a3847c9">getremotehostname</a> (std::string *name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the hostname of the remote computer.  <a href="#6f9cc823f1a72f7d4e35bbc63a3847c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#8f52182f845120bd623de47af6eee006">getClosedPort</a> (<a class="el" href="classMercury_1_1Address.html">Mercury::Address</a> &amp;closedPort)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method gets the address of the UDP port that has closed.  <a href="#8f52182f845120bd623de47af6eee006"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Connectionless Socket Methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#0139f002887540b925703c91d87e1457">sendto</a> (void *gramData, int gramSize, <a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a> networkPort, <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> networkAddr=<a class="el" href="basictypes_8hpp.html#273eec32c95bf026ccdb6a92ba348b4a">BROADCAST</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sends a packet to the given address.  <a href="#0139f002887540b925703c91d87e1457"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#17bf81144754bdd5cfe5965320a440bc">sendto</a> (void *gramData, int gramSize, struct sockaddr_in &amp;sin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sends a packet to the given address.  <a href="#17bf81144754bdd5cfe5965320a440bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#53816694d76d4210614d65ed929dfec6">recvfrom</a> (void *gramData, int gramSize, <a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a> *networkPort, <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> *networkAddr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method attempts to receive a packet.  <a href="#53816694d76d4210614d65ed929dfec6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#3af113c91e514156895d82efc21f447a">recvfrom</a> (void *gramData, int gramSize, struct sockaddr_in &amp;sin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method attempts to receive a packet.  <a href="#3af113c91e514156895d82efc21f447a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Connecting Socket Methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#673139b13623ff9b9faa1d75d94d2608">listen</a> (int backlog=5)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method instructs this endpoint to listen for incoming connections.  <a href="#673139b13623ff9b9faa1d75d94d2608"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#7364ecdfbb73c26d820244209de947f6">connect</a> (<a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a> networkPort, <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> networkAddr=<a class="el" href="basictypes_8hpp.html#273eec32c95bf026ccdb6a92ba348b4a">BROADCAST</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method connections this endpoint to a destination address.  <a href="#7364ecdfbb73c26d820244209de947f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classEndpoint.html">Endpoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#fa224e0260b1242740f3d47af50de982">accept</a> (<a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a> *networkPort=NULL, <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> *networkAddr=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method accepts a connection on the socket listen queue, returning a new endpoint if successful, or NULL if not.  <a href="#fa224e0260b1242740f3d47af50de982"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#cf83fcb424d4733144b70d06b8ee8681">send</a> (const void *gramData, int gramSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sends some data to the given address.  <a href="#cf83fcb424d4733144b70d06b8ee8681"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#358201ebc98070f5794bd2ffb2b9ca81">recv</a> (void *gramData, int gramSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method attempts to receive some data.  <a href="#358201ebc98070f5794bd2ffb2b9ca81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#66ace1438344d0b68893258ee8b4ad69">recvAll</a> (void *gramData, int gramSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This helper method wait until exactly gramSize data has been read.  <a href="#66ace1438344d0b68893258ee8b4ad69"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Queue Size Methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#105f2716b792f13cf1458c75016ba2ae">transmitQueueSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the current size of the transmit queue for this socket.  <a href="#105f2716b792f13cf1458c75016ba2ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#7e4e0444dfdede07eb9ee510567edd88">receiveQueueSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the current size of the receive queue for this socket.  <a href="#7e4e0444dfdede07eb9ee510567edd88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#5841a7bbeacb919b717fa667e6ca0a0a">getQueueSizes</a> (int &amp;tx, int &amp;rx) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the current size of the transmit and receive queues for this socket.  <a href="#5841a7bbeacb919b717fa667e6ca0a0a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Buffer Size Methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#c25922757cb826cb42f06faed5e8ce66">getBufferSize</a> (int optname) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns either the send or receive buffer size for this socket, or -1 on error.  <a href="#c25922757cb826cb42f06faed5e8ce66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#4e809c2acdf84451822444abe18c4450">setBufferSize</a> (int optname, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets either the send or receive buffer size for this socket.  <a href="#4e809c2acdf84451822444abe18c4450"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEndpoint.html#2c4b88efa30242e8c4f9f4a17b3c737d">NO_SOCKET</a> = -1</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class provides a wrapper around a socket. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="d4730afc3c8453cc37b3c9a7baa44156"></a><!-- doxytag: member="Endpoint::Endpoint" ref="d4730afc3c8453cc37b3c9a7baa44156" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Endpoint::Endpoint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the default constructor. 
<p>
The socket is not created until the socket method is called.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classEndpoint.html#cb67df89f00a53caefa74a27a698cc32">socket(int type)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b64a9b395d12d536348ad05f795c88d8"></a><!-- doxytag: member="Endpoint::~Endpoint" ref="b64a9b395d12d536348ad05f795c88d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Endpoint::~Endpoint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the destructor. 
<p>
Note: use 'detach' if you don't want your socket to disappear when the <a class="el" href="classEndpoint.html">Endpoint</a> is destructed.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classEndpoint.html#401a40954e086d5df4b5702625caecfd">detach</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="fa224e0260b1242740f3d47af50de982"></a><!-- doxytag: member="Endpoint::accept" ref="fa224e0260b1242740f3d47af50de982" args="(u_int16_t *networkPort=NULL, u_int32_t *networkAddr=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEndpoint.html">Endpoint</a> * Endpoint::accept           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a> *&nbsp;</td>
          <td class="paramname"> <em>networkPort</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> *&nbsp;</td>
          <td class="paramname"> <em>networkAddr</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method accepts a connection on the socket listen queue, returning a new endpoint if successful, or NULL if not. 
<p>
The remote port and address are set into the pointers passed in if not NULL. 
</div>
</div><p>
<a class="anchor" name="5a6977fce5e96295c8738c3ea930d083"></a><!-- doxytag: member="Endpoint::bind" ref="5a6977fce5e96295c8738c3ea930d083" args="(u_int16_t networkPort=0, u_int32_t networkAddr=INADDR_ANY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::bind           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a>&nbsp;</td>
          <td class="paramname"> <em>networkPort</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a>&nbsp;</td>
          <td class="paramname"> <em>networkAddr</em> = <code>INADDR_ANY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method binds the socket to a given address and port. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>networkPort</em>&nbsp;</td><td>The port, in network byte order. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>networkAddr</em>&nbsp;</td><td>The address, in network byte order.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if successful, -1 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="403b88cdf7ea64c1888f99ab4d0a2556"></a><!-- doxytag: member="Endpoint::c_str" ref="403b88cdf7ea64c1888f99ab4d0a2556" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Endpoint::c_str           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the string representation of the address this endpoint is bound to. 
<p>

</div>
</div><p>
<a class="anchor" name="09102067d11fc8a0e303d54dcbbf6c49"></a><!-- doxytag: member="Endpoint::close" ref="09102067d11fc8a0e303d54dcbbf6c49" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method closes the socket associated with this endpoint. 
<p>

</div>
</div><p>
<a class="anchor" name="7364ecdfbb73c26d820244209de947f6"></a><!-- doxytag: member="Endpoint::connect" ref="7364ecdfbb73c26d820244209de947f6" args="(u_int16_t networkPort, u_int32_t networkAddr=BROADCAST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::connect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a>&nbsp;</td>
          <td class="paramname"> <em>networkPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a>&nbsp;</td>
          <td class="paramname"> <em>networkAddr</em> = <code><a class="el" href="basictypes_8hpp.html#273eec32c95bf026ccdb6a92ba348b4a">BROADCAST</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method connections this endpoint to a destination address. 
<p>

</div>
</div><p>
<a class="anchor" name="509eb4888e5315e419260acf814232cb"></a><!-- doxytag: member="Endpoint::convertAddress" ref="509eb4888e5315e419260acf814232cb" args="(const char *string, u_int32_t &amp;address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::convertAddress           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method converts a string containing an IP address into a 32 integer in network byte order. 
<p>
It handles both numeric and named addresses.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The address as a string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>The address is returned here as an integer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if successful, -1 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="401a40954e086d5df4b5702625caecfd"></a><!-- doxytag: member="Endpoint::detach" ref="401a40954e086d5df4b5702625caecfd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::detach           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method detaches the socket from this endpoint. 
<p>
When the destructor is called, the socket will not be automatically closed. 
</div>
</div><p>
<a class="anchor" name="e6142dee4fac0a54a2e3333efb94d195"></a><!-- doxytag: member="Endpoint::findDefaultInterface" ref="e6142dee4fac0a54a2e3333efb94d195" args="(char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::findDefaultInterface           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function finds the default interface, i.e. 
<p>
the one to use if an IP address is required for a socket that is bound to all interfaces.<p>
Currently, the first valid (non-loopback) interface is used, but this should really be changed to be whatever interface is used by a local network broadcast - i.e. the interface that the default route goes over 
</div>
</div><p>
<a class="anchor" name="29837428a26dccaca740c4f83320d6c0"></a><!-- doxytag: member="Endpoint::findIndicatedInterface" ref="29837428a26dccaca740c4f83320d6c0" args="(const char *spec, char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::findIndicatedInterface           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function finds the interfaced specified by a string. 
<p>
The specification may take the form of a straight interface name, a IP address (name/dotted decimal), or a netmask (IP/bits). 
</div>
</div><p>
<a class="anchor" name="c25922757cb826cb42f06faed5e8ce66"></a><!-- doxytag: member="Endpoint::getBufferSize" ref="c25922757cb826cb42f06faed5e8ce66" args="(int optname) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::getBufferSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>optname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns either the send or receive buffer size for this socket, or -1 on error. 
<p>
You should pass either SO_RCVBUF or SO_SNDBUF as the argument to this method. 
</div>
</div><p>
<a class="anchor" name="8f52182f845120bd623de47af6eee006"></a><!-- doxytag: member="Endpoint::getClosedPort" ref="8f52182f845120bd623de47af6eee006" args="(Mercury::Address &amp;closedPort)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Endpoint::getClosedPort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMercury_1_1Address.html">Mercury::Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>closedPort</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method gets the address of the UDP port that has closed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>closedPort</em>&nbsp;</td><td>A reference to the address that is to receive the address of the closed port.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if closedPort was set, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7434052e2d5f2eccd288fb5a5d7af994"></a><!-- doxytag: member="Endpoint::getInterfaceAddress" ref="7434052e2d5f2eccd288fb5a5d7af994" args="(const char *name, u_int32_t &amp;address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::getInterfaceAddress           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the address to which an interface is bound. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the interface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>The address is returned here.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if successful, 1 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca294094f102a5f9c0ed81831b402325"></a><!-- doxytag: member="Endpoint::getInterfaceFlags" ref="ca294094f102a5f9c0ed81831b402325" args="(char *name, int &amp;flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::getInterfaceFlags           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the flags associated with the given interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Interface name for which flags are needed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The flags are returned here.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if successful, 1 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8988f8fc548d19c73dafde09ea665c31"></a><!-- doxytag: member="Endpoint::getInterfaceNetmask" ref="8988f8fc548d19c73dafde09ea665c31" args="(const char *name, u_int32_t &amp;netmask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::getInterfaceNetmask           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>netmask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="92a10f1f19b22488ede5d6436cc7373c"></a><!-- doxytag: member="Endpoint::getInterfaces" ref="92a10f1f19b22488ede5d6436cc7373c" args="(std::map&lt; u_int32_t, std::string &gt; &amp;interfaces)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Endpoint::getInterfaces           </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a>, std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>interfaces</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a address/name map of all network interfaces. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interfaces</em>&nbsp;</td><td>The map to populate with the interface list.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true on success, false on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="556fed718ea7392a0d29aab0d0fc5101"></a><!-- doxytag: member="Endpoint::getLocalAddress" ref="556fed718ea7392a0d29aab0d0fc5101" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMercury_1_1Address.html">Mercury::Address</a> Endpoint::getLocalAddress           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the address that this endpoint is bound to. 
<p>

</div>
</div><p>
<a class="anchor" name="2e2a986916866ca60468808f430c29af"></a><!-- doxytag: member="Endpoint::getlocaladdress" ref="2e2a986916866ca60468808f430c29af" args="(u_int16_t *networkPort, u_int32_t *networkAddr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::getlocaladdress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a> *&nbsp;</td>
          <td class="paramname"> <em>networkPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> *&nbsp;</td>
          <td class="paramname"> <em>networkAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the local address and port to which this endpoint is bound. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>networkPort</em>&nbsp;</td><td>The port is returned here in network byte order. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>networkAddr</em>&nbsp;</td><td>The address is returned here in network byte order.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5841a7bbeacb919b717fa667e6ca0a0a"></a><!-- doxytag: member="Endpoint::getQueueSizes" ref="5841a7bbeacb919b717fa667e6ca0a0a" args="(int &amp;tx, int &amp;rx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::getQueueSizes           </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>rx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the current size of the transmit and receive queues for this socket. 
<p>
This method is only implemented on Unix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tx</em>&nbsp;</td><td>The current size of the transmit queue is returned here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rx</em>&nbsp;</td><td>The current size of the receive queue is returned here.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if successful, -1 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7022bd2868ba5581c9c838eb2dc05185"></a><!-- doxytag: member="Endpoint::getRemoteAddress" ref="7022bd2868ba5581c9c838eb2dc05185" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMercury_1_1Address.html">Mercury::Address</a> Endpoint::getRemoteAddress           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the address that this endpoint is bound to. 
<p>

</div>
</div><p>
<a class="anchor" name="76593ac78ac0a6811e7f0e2446656522"></a><!-- doxytag: member="Endpoint::getremoteaddress" ref="76593ac78ac0a6811e7f0e2446656522" args="(u_int16_t *networkPort, u_int32_t *networkAddr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::getremoteaddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a> *&nbsp;</td>
          <td class="paramname"> <em>networkPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> *&nbsp;</td>
          <td class="paramname"> <em>networkAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the remote address and port to which this endpoint is connected. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>networkPort</em>&nbsp;</td><td>The port is returned here in network byte order. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>networkAddr</em>&nbsp;</td><td>The address is returned here in network byte order.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f9cc823f1a72f7d4e35bbc63a3847c9"></a><!-- doxytag: member="Endpoint::getremotehostname" ref="6f9cc823f1a72f7d4e35bbc63a3847c9" args="(std::string *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::getremotehostname           </td>
          <td>(</td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>host</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the hostname of the remote computer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>host</em>&nbsp;</td><td>The string to return the hostname in</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f4fa84c70d419d0c77d76cc6f0a9294f"></a><!-- doxytag: member="Endpoint::good" ref="f4fa84c70d419d0c77d76cc6f0a9294f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Endpoint::good           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns true if this endpoint is a valid socket. 
<p>

</div>
</div><p>
<a class="anchor" name="483dd0b25562c8e49e1863e2a455abfa"></a><!-- doxytag: member="Endpoint::joinMulticastGroup" ref="483dd0b25562c8e49e1863e2a455abfa" args="(u_int32_t networkAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::joinMulticastGroup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a>&nbsp;</td>
          <td class="paramname"> <em>networkAddr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method joins the socket up to the given multicast group. 
<p>

</div>
</div><p>
<a class="anchor" name="673139b13623ff9b9faa1d75d94d2608"></a><!-- doxytag: member="Endpoint::listen" ref="673139b13623ff9b9faa1d75d94d2608" args="(int backlog=5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::listen           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em> = <code>5</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method instructs this endpoint to listen for incoming connections. 
<p>

</div>
</div><p>
<a class="anchor" name="46ce3c9f408f45959321af3ed4fa2837"></a><!-- doxytag: member="Endpoint::operator int" ref="46ce3c9f408f45959321af3ed4fa2837" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Endpoint::operator int           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operator returns the file descriptor for this endpoint. 
<p>

</div>
</div><p>
<a class="anchor" name="78dbcd73aa7a4e1c57b6da6e49c71573"></a><!-- doxytag: member="Endpoint::quitMulticastGroup" ref="78dbcd73aa7a4e1c57b6da6e49c71573" args="(u_int32_t networkAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::quitMulticastGroup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a>&nbsp;</td>
          <td class="paramname"> <em>networkAddr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method gets the socket to quit the given multicast group. 
<p>

</div>
</div><p>
<a class="anchor" name="7e4e0444dfdede07eb9ee510567edd88"></a><!-- doxytag: member="Endpoint::receiveQueueSize" ref="7e4e0444dfdede07eb9ee510567edd88" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::receiveQueueSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the current size of the receive queue for this socket. 
<p>
It is only implemented on Unix.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Current receive queue size in bytes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="358201ebc98070f5794bd2ffb2b9ca81"></a><!-- doxytag: member="Endpoint::recv" ref="358201ebc98070f5794bd2ffb2b9ca81" args="(void *gramData, int gramSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::recv           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>gramData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gramSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method attempts to receive some data. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gramData</em>&nbsp;</td><td>Pointer to a data buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gramSize</em>&nbsp;</td><td>Number of bytes in the data buffer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes received, or -1 if an error occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66ace1438344d0b68893258ee8b4ad69"></a><!-- doxytag: member="Endpoint::recvAll" ref="66ace1438344d0b68893258ee8b4ad69" args="(void *gramData, int gramSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Endpoint::recvAll           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>gramData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gramSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This helper method wait until exactly gramSize data has been read. 
<p>
True if gramSize was read, otherwise false (usually indicating the connection was lost. 
</div>
</div><p>
<a class="anchor" name="3af113c91e514156895d82efc21f447a"></a><!-- doxytag: member="Endpoint::recvfrom" ref="3af113c91e514156895d82efc21f447a" args="(void *gramData, int gramSize, struct sockaddr_in &amp;sin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::recvfrom           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>gramData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gramSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_in &amp;&nbsp;</td>
          <td class="paramname"> <em>sin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method attempts to receive a packet. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gramData</em>&nbsp;</td><td>Pointer to a data buffer to receive the packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gramSize</em>&nbsp;</td><td>Number of bytes in the data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sin</em>&nbsp;</td><td>The address from which the packet originated is returned here.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes received, or -1 if an error occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="53816694d76d4210614d65ed929dfec6"></a><!-- doxytag: member="Endpoint::recvfrom" ref="53816694d76d4210614d65ed929dfec6" args="(void *gramData, int gramSize, u_int16_t *networkPort, u_int32_t *networkAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::recvfrom           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>gramData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gramSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a> *&nbsp;</td>
          <td class="paramname"> <em>networkPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a> *&nbsp;</td>
          <td class="paramname"> <em>networkAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method attempts to receive a packet. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gramData</em>&nbsp;</td><td>Pointer to a data buffer to receive the packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gramSize</em>&nbsp;</td><td>Number of bytes in the data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>networkPort</em>&nbsp;</td><td>The port from which the packet originated is returned here, if this pointer is non-NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>networkAddr</em>&nbsp;</td><td>The address from which the packet originated is returned here, if this pointer is non-NULL.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes received, or -1 if an error occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf83fcb424d4733144b70d06b8ee8681"></a><!-- doxytag: member="Endpoint::send" ref="cf83fcb424d4733144b70d06b8ee8681" args="(const void *gramData, int gramSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::send           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>gramData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gramSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sends some data to the given address. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gramData</em>&nbsp;</td><td>Pointer to a data buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gramSize</em>&nbsp;</td><td>Number of bytes in the data buffer. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="17bf81144754bdd5cfe5965320a440bc"></a><!-- doxytag: member="Endpoint::sendto" ref="17bf81144754bdd5cfe5965320a440bc" args="(void *gramData, int gramSize, struct sockaddr_in &amp;sin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::sendto           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>gramData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gramSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr_in &amp;&nbsp;</td>
          <td class="paramname"> <em>sin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sends a packet to the given address. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gramData</em>&nbsp;</td><td>Pointer to a data buffer containing the packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gramSize</em>&nbsp;</td><td>Number of bytes in the data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sin</em>&nbsp;</td><td>Destination address. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0139f002887540b925703c91d87e1457"></a><!-- doxytag: member="Endpoint::sendto" ref="0139f002887540b925703c91d87e1457" args="(void *gramData, int gramSize, u_int16_t networkPort, u_int32_t networkAddr=BROADCAST)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::sendto           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>gramData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gramSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#38ba3db69a777e7ed5278127dde2f8c6">u_int16_t</a>&nbsp;</td>
          <td class="paramname"> <em>networkPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="endpoint_8hpp.html#342aee0755aa8473dbd5e27c03baba7c">u_int32_t</a>&nbsp;</td>
          <td class="paramname"> <em>networkAddr</em> = <code><a class="el" href="basictypes_8hpp.html#273eec32c95bf026ccdb6a92ba348b4a">BROADCAST</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sends a packet to the given address. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gramData</em>&nbsp;</td><td>Pointer to a data buffer containing the packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gramSize</em>&nbsp;</td><td>Number of bytes in the data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>networkPort</em>&nbsp;</td><td>Destination port, in network byte order. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>networkAddr</em>&nbsp;</td><td>Destination address, in network byte order. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5f84deda0721079d9fec7aa88ab20bfe"></a><!-- doxytag: member="Endpoint::setbroadcast" ref="5f84deda0721079d9fec7aa88ab20bfe" args="(bool broadcast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::setbroadcast           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method toggles the broadcast mode of the socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>broadcast</em>&nbsp;</td><td>The desired broadcast mode. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4e809c2acdf84451822444abe18c4450"></a><!-- doxytag: member="Endpoint::setBufferSize" ref="4e809c2acdf84451822444abe18c4450" args="(int optname, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Endpoint::setBufferSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets either the send or receive buffer size for this socket. 
<p>
You should pass either SO_RCVBUF or SO_SNDBUF as the optname argument to this method. 
</div>
</div><p>
<a class="anchor" name="5f687f3f3844e99330cd7ed84fc33e90"></a><!-- doxytag: member="Endpoint::setFileDescriptor" ref="5f687f3f3844e99330cd7ed84fc33e90" args="(int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Endpoint::setFileDescriptor           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets the file descriptor used by this endpoint. 
<p>

</div>
</div><p>
<a class="anchor" name="43af92a5b5f1c3b279d3bfa342de7a46"></a><!-- doxytag: member="Endpoint::setkeepalive" ref="43af92a5b5f1c3b279d3bfa342de7a46" args="(bool keepalive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::setkeepalive           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keepalive</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cf4bfc4ec6e73c14d880498433f8daf7"></a><!-- doxytag: member="Endpoint::setnonblocking" ref="cf4bfc4ec6e73c14d880498433f8daf7" args="(bool nonblocking)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::setnonblocking           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>nonblocking</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method controls the blocking mode of the socket. 
<p>
When a socket is set to non-blocking mode, socket calls will return immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nonblocking</em>&nbsp;</td><td>The desired blocking mode. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="da50f9335e99f92f467169dae500e6d3"></a><!-- doxytag: member="Endpoint::setreuseaddr" ref="da50f9335e99f92f467169dae500e6d3" args="(bool reuseaddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::setreuseaddr           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reuseaddr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method toggles the reuse address mode of the socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reuseaddr</em>&nbsp;</td><td>The desired reuse address mode. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cb67df89f00a53caefa74a27a698cc32"></a><!-- doxytag: member="Endpoint::socket" ref="cb67df89f00a53caefa74a27a698cc32" args="(int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Endpoint::socket           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method creates a socket of the requested type. 
<p>
It initialises Winsock if necessary.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Normally SOCK_STREAM or SOCK_DGRAM </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="105f2716b792f13cf1458c75016ba2ae"></a><!-- doxytag: member="Endpoint::transmitQueueSize" ref="105f2716b792f13cf1458c75016ba2ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Endpoint::transmitQueueSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the current size of the transmit queue for this socket. 
<p>
It is only implemented on Unix.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Current transmit queue size in bytes. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="2c4b88efa30242e8c4f9f4a17b3c737d"></a><!-- doxytag: member="Endpoint::NO_SOCKET" ref="2c4b88efa30242e8c4f9f4a17b3c737d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classEndpoint.html#2c4b88efa30242e8c4f9f4a17b3c737d">Endpoint::NO_SOCKET</a> = -1<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="endpoint_8hpp.html">endpoint.hpp</a><li><a class="el" href="endpoint_8cpp.html">endpoint.cpp</a><li><a class="el" href="endpoint_8ipp.html">endpoint.ipp</a></ul>
<p class="copyrightFooter">Copyright 1999-2010 BigWorld Pty. Ltd. All rights reserved. Proprietary commercial in confidence.</p>

</body>
</html>
