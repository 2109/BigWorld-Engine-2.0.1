<html>
  <head><link rel="stylesheet" type="text/css" href="doxygen.css"></head>
  <body>
    <table width="100%" border="0" cellpadding="0" cellspacing="0">
        <tr> <td align=left style="background:#0F5286"> <img src="bwlogo_bluebkg.png"> </td> </tr>
    </table>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>Watcher Module<br>
<small>
[<a class="el" href="group__cstdmf.html">cstdmf</a>]</small>
</h1>
<p>
Collaboration diagram for Watcher Module:<center><table><tr><td><img src="group__WatcherModule.png" border="0" alt="" usemap="#group____WatcherModule_map">
<map name="group____WatcherModule_map">
<area href="group__cstdmf.html" shape="rect" coords="5,5,72,32" alt="">
</map></td></tr></table></center>
This modules contains the parts of BigWorld that are used to watch values at run-time.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWatcher.html">Watcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is the base class for all debug value watchers.  <a href="classWatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWatcherVisitor.html">WatcherVisitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This interface is used to implement a visitor.  <a href="classWatcherVisitor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDirectoryWatcher.html">DirectoryWatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class implements a <a class="el" href="classWatcher.html">Watcher</a> that can contain other Watchers.  <a href="classDirectoryWatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequenceWatcher.html">SequenceWatcher&lt; SEQ &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used for watching the contents of vectors and other sequences.  <a href="classSequenceWatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapWatcher.html">MapWatcher&lt; MAP &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used for watching the contents of maps.  <a href="classMapWatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDereferenceWatcher.html">DereferenceWatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This abstract class from which watchers meant to access indirect bases derive.  <a href="classDereferenceWatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseDereferenceWatcher.html">BaseDereferenceWatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is a helper watcher that wraps another <a class="el" href="classWatcher.html">Watcher</a>.  <a href="classBaseDereferenceWatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmartPointerDereferenceWatcher.html">SmartPointerDereferenceWatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is a helper watcher that wraps another <a class="el" href="classWatcher.html">Watcher</a>.  <a href="classSmartPointerDereferenceWatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContainerBounceWatcher.html">ContainerBounceWatcher&lt; CONTAINER_TYPE, KEY_TYPE &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is a helper watcher that wraps another <a class="el" href="classWatcher.html">Watcher</a>.  <a href="classContainerBounceWatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemberWatcher.html">MemberWatcher&lt; RETURN_TYPE, OBJECT_TYPE, CONSTRUCTION_TYPE &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This templatised class is used to store debug values that are a member of a class.  <a href="classMemberWatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataWatcher.html">DataWatcher&lt; TYPE &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This templatised class is used to watch a given bit a data.  <a href="classDataWatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionWatcher.html">FunctionWatcher&lt; RETURN_TYPE, CONSTRUCTION_TYPE &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This templatised class is used to watch the result of a given function.  <a href="classFunctionWatcher.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g699c5edf8c153f0d0293484853654246">MF_WATCH</a>&nbsp;&nbsp;&nbsp;::addWatcher</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro is used to watch a value at run-time for debugging purposes.  <a href="#g699c5edf8c153f0d0293484853654246"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g7dc30c48803ea991219fb18a351979a6">MF_WATCH_REF</a>&nbsp;&nbsp;&nbsp;::addReferenceWatcher</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro is used to watch a value at run-time for debugging purposes.  <a href="#g7dc30c48803ea991219fb18a351979a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g429249ca76b29ff8fafe19ee6afdb56d">MF_ACCESSORS</a>(TYPE, CLASS, METHOD)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a simple macro that helps us do casting.  <a href="#g429249ca76b29ff8fafe19ee6afdb56d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#ga8606d3583be4a7bc1f86e58f5fd547a">MF_WRITE_ACCESSOR</a>(TYPE, CLASS, METHOD)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro is like MF_ACCESSORS except that the read accessor is NULL.  <a href="#ga8606d3583be4a7bc1f86e58f5fd547a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g207d12b4ac18e7dd3b33311b79ea4ae2">MF_READ_ACCESSOR</a>(TYPE, CLASS, METHOD)&nbsp;&nbsp;&nbsp;static_cast&lt; TYPE (CLASS::*)() const &gt;( NULL )</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro is like MF_ACCESSORS except that no WRITE method is generated.  <a href="#g207d12b4ac18e7dd3b33311b79ea4ae2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#gb6603aeeb257208647b387aa49f58145">makeWatcher</a> (const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const )</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to create a read-only watcher using a get method.  <a href="#gb6603aeeb257208647b387aa49f58145"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g3633e592a744e05b3cec3d59da3f6b58">makeWatcher</a> (const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(const RETURN_TYPE &amp;))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to create a read/write watcher using a get and set methods.  <a href="#g3633e592a744e05b3cec3d59da3f6b58"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g90c396ac7763a388c4e9ab46bca4771d">makeWatcher</a> (RETURN_TYPE(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(RETURN_TYPE))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to create a read/write watcher using a get and set methods.  <a href="#g90c396ac7763a388c4e9ab46bca4771d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g1ff9b571f4be01c90fe05117fca721fe">makeWatcher</a> (RETURN_TYPE(OBJECT_TYPE::*getMethod)() const )</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to create a read-only watcher using a get method.  <a href="#g1ff9b571f4be01c90fe05117fca721fe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g9656896abd78d02b7e2660ce68b0020e">makeNonRefWatcher</a> (RETURN_TYPE(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(RETURN_TYPE), const char *comment=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to create a read/write watcher using a get and set methods.  <a href="#g9656896abd78d02b7e2660ce68b0020e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g79011afb5d44b9c7b2cbce6cf7932acd">makeWatcher</a> (OBJECT_TYPE &amp;rObject, const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const )</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to create a read-only watcher using a get method.  <a href="#g79011afb5d44b9c7b2cbce6cf7932acd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g039ec5fb04c70687d588e712c4bd67ee">makeWatcher</a> (OBJECT_TYPE &amp;rObject, const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(const RETURN_TYPE &amp;))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to create a read/write watcher using a get and set methods.  <a href="#g039ec5fb04c70687d588e712c4bd67ee"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g083d64201e10ebd6d70fa64317693509">makeWatcher</a> (OBJECT_TYPE &amp;rObject, RETURN_TYPE(OBJECT_TYPE::*getMethod)() const )</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to create a read-only watcher using a get method.  <a href="#g083d64201e10ebd6d70fa64317693509"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g0b506ede5f4704718a6c511c5db37875">makeNonRefWatcher</a> (OBJECT_TYPE &amp;rObject, RETURN_TYPE(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(RETURN_TYPE), const char *comment=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to create a read/write watcher using a get and set methods.  <a href="#g0b506ede5f4704718a6c511c5db37875"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g87c3751dfee6e6aa4b5d2b0bf58b7404">addReferenceWatcher</a> (const char *path, OBJECT_TYPE &amp;rObject, const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const, const char *comment=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to add a read-only watcher using a get-accessor method.  <a href="#g87c3751dfee6e6aa4b5d2b0bf58b7404"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g5a1bf922da7fcf5d62f3d450d53d4bfa">addReferenceWatcher</a> (const char *path, OBJECT_TYPE &amp;rObject, const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(const RETURN_TYPE &amp;), const char *comment=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to add a read/write watcher using a get and set methods.  <a href="#g5a1bf922da7fcf5d62f3d450d53d4bfa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#gab9285936cb06ad409ef9543005438df">addWatcher</a> (const char *path, OBJECT_TYPE &amp;rObject, RETURN_TYPE(OBJECT_TYPE::*getMethod)() const, const char *comment=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to add a read-only watcher using a get-accessor method.  <a href="#gab9285936cb06ad409ef9543005438df"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#ga8e91a6e82eb77cc71e69f7f3c65dd22">addWatcher</a> (const char *path, OBJECT_TYPE &amp;rObject, RETURN_TYPE(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(RETURN_TYPE), const char *comment=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to add a read/write watcher using a get and set accessor methods.  <a href="#ga8e91a6e82eb77cc71e69f7f3c65dd22"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RETURN_TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#gbb7318937b0d2130eb750685026d7165">addWatcher</a> (const char *path, RETURN_TYPE(*getFunction)(), void(*setFunction)(RETURN_TYPE)=NULL, const char *comment=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to add a watcher of a function value.  <a href="#gbb7318937b0d2130eb750685026d7165"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">WatcherPtr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#g3569563fee616fa3a122970783d25b1c">addWatcher</a> (const char *path, TYPE &amp;rValue, <a class="el" href="classWatcher.html#d89641290730ac55095dce0ef1f72510">Watcher::Mode</a> access=Watcher::WT_READ_WRITE, const char *comment=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to add a watcher of a simple value.  <a href="#g3569563fee616fa3a122970783d25b1c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__WatcherModule.html#gc85e08aa4f1a823ddae78c265075ac2e">WATCHER_SEPARATOR</a> = '/'</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The character that separates values in a watcher path.  <a href="#gc85e08aa4f1a823ddae78c265075ac2e"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This modules contains the parts of BigWorld that are used to watch values at run-time. 
<p>
The main use of this is for debugging.<p>
This module allows a wide variety of values to be inspected or changed through either the client interface, or a Web or telnet interface.<p>
The main mechanism to add a value to be watched is by using the <hr><h2>Define Documentation</h2>
<a class="anchor" name="g429249ca76b29ff8fafe19ee6afdb56d"></a><!-- doxytag: member="watcher.hpp::MF_ACCESSORS" ref="g429249ca76b29ff8fafe19ee6afdb56d" args="(TYPE, CLASS, METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MF_ACCESSORS          </td>
          <td>(</td>
          <td class="paramtype">TYPE,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">METHOD&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">static_cast&lt; TYPE (CLASS::*)() const &gt;(&amp;CLASS::METHOD),         \
    <span class="keyword">static_cast</span>&lt; <span class="keywordtype">void</span> (CLASS::*)(TYPE)   &gt;(&amp;CLASS::METHOD)
</pre></div>This is a simple macro that helps us do casting. 
<p>
This allows us to do<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="doc__watcher_8hpp.html#f66f3cf25cd56fda5f4371eed789697a">MF_WATCH</a>(  <span class="stringliteral">"Comms/Desired in"</span>,
        g_server,
        <a class="code" href="group__WatcherModule.html#g429249ca76b29ff8fafe19ee6afdb56d">MF_ACCESSORS</a>( <a class="code" href="stdmf_8hpp.html#0e55fb2a49437eb666626ca96962e6a2">uint32</a>, <a class="code" href="classServerConnection.html">ServerConnection</a>, bandwidthFromServer ) );
</pre></div><p>
instead of<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="doc__watcher_8hpp.html#f66f3cf25cd56fda5f4371eed789697a">MF_WATCH</a>( <span class="stringliteral">"Comms/Desired in"</span>,
        g_server,
        (<a class="code" href="stdmf_8hpp.html#0e55fb2a49437eb666626ca96962e6a2">uint32</a> (MyClass::*)() <span class="keyword">const</span>)(MyClass::bandwidthFromServer),
        (<span class="keywordtype">void</span>   (MyClass::*)(<a class="code" href="stdmf_8hpp.html#0e55fb2a49437eb666626ca96962e6a2">uint32</a>))(MyClass::bandwidthFromServer) );
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g207d12b4ac18e7dd3b33311b79ea4ae2"></a><!-- doxytag: member="watcher.hpp::MF_READ_ACCESSOR" ref="g207d12b4ac18e7dd3b33311b79ea4ae2" args="(TYPE, CLASS, METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MF_READ_ACCESSOR          </td>
          <td>(</td>
          <td class="paramtype">TYPE,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">METHOD&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;static_cast&lt; TYPE (CLASS::*)() const &gt;( NULL )</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro is like MF_ACCESSORS except that no WRITE method is generated. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__WatcherModule.html#g429249ca76b29ff8fafe19ee6afdb56d">MF_ACCESSORS</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g699c5edf8c153f0d0293484853654246"></a><!-- doxytag: member="watcher.hpp::MF_WATCH" ref="g699c5edf8c153f0d0293484853654246" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MF_WATCH&nbsp;&nbsp;&nbsp;::addWatcher          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro is used to watch a value at run-time for debugging purposes. 
<p>
This value can then be inspected and changed at run-time through a variety of methods. These include using the Web interface or using the in-built menu system in an appropriate build of the client. (This is displayed by pressing &lt;F7&gt;.)<p>
The simplest usage of this macro is when you want to watch a fixed variable such as a global or a variable that is static to a file, class, or method. The macro should be called once during initialisation for each value that is to be watched.<p>
For example, to watch a value that is static to a file, do the following:<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">static</span> <span class="keywordtype">int</span> myValue = 72;
    ...
    <a class="code" href="doc__watcher_8hpp.html#f66f3cf25cd56fda5f4371eed789697a">MF_WATCH</a>( <span class="stringliteral">"myValue"</span>, myValue );
</pre></div><p>
This allows you to inspect and change the value of <em>myValue</em>. The first argument to the macro is a string specifying the path associated with this value. This is used in displaying and setting this value via the different Watcher interfaces.<p>
If you want to not allow the value to be changed using the Watch interfaces, include the extra argument <a class="el" href="classWatcher.html#d89641290730ac55095dce0ef1f72510bc6909fdf1f59430907e19e24d76c6a5">Watcher::WT_READ_ONLY</a>.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="doc__watcher_8hpp.html#f66f3cf25cd56fda5f4371eed789697a">MF_WATCH</a>( <span class="stringliteral">"myValue"</span>, myValue, WT_READ_ONLY );
</pre></div><p>
Any type of value can be watched as long as it has streaming operators to ostream and istream.<p>
You can also look at a value associated with an object using accessor methods on that object.<p>
For example, if you had the following class: <div class="fragment"><pre class="fragment">    <span class="keyword">class </span>ExampleClass
    {
        <span class="keyword">public</span>:
            <span class="keywordtype">int</span> <a class="code" href="py__entities_8cpp.html#fa24d01616b34ca7246e88c39b51c126">getValue</a>() <span class="keyword">const</span>;
            <span class="keywordtype">void</span> setValue( <span class="keywordtype">int</span> setValue ) <span class="keyword">const</span>;
    };

    ExampleClass exampleObject_;
</pre></div><p>
You can watch this value as follows: <div class="fragment"><pre class="fragment">    <a class="code" href="doc__watcher_8hpp.html#f66f3cf25cd56fda5f4371eed789697a">MF_WATCH</a>( <span class="stringliteral">"some value"</span>, exampleObject_,
            <a class="code" href="py__entities_8cpp.html#fa24d01616b34ca7246e88c39b51c126">ExampleClass::getValue</a>,
            ExampleClass::setValue );
</pre></div><p>
If you have overloaded your accessor methods, use the <a class="el" href="group__WatcherModule.html#g429249ca76b29ff8fafe19ee6afdb56d">MF_ACCESSORS</a> macro to help with casting.<p>
If you want the value to be read-only, do not add the set accessor to the macro call. <div class="fragment"><pre class="fragment">    <a class="code" href="doc__watcher_8hpp.html#f66f3cf25cd56fda5f4371eed789697a">MF_WATCH</a>( <span class="stringliteral">"some value"</span>, exampleObject_,
            <a class="code" href="py__entities_8cpp.html#fa24d01616b34ca7246e88c39b51c126">ExampleClass::getValue</a> );
</pre></div><p>
If you want to watch a value and the accessors take and return a reference to the object, instead of a copy of the object.
</div>
</div><p>
<a class="anchor" name="g7dc30c48803ea991219fb18a351979a6"></a><!-- doxytag: member="watcher.hpp::MF_WATCH_REF" ref="g7dc30c48803ea991219fb18a351979a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MF_WATCH_REF&nbsp;&nbsp;&nbsp;::addReferenceWatcher          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro is used to watch a value at run-time for debugging purposes. 
<p>
This macro should be used instead of MF_WATCH if the accessors take and return a reference to the object being watched.<p>
For example,<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">class </span>ExampleClass
    {
        <span class="keyword">const</span> <a class="code" href="classVector3.html">Vector3</a> &amp; getPosition() <span class="keyword">const</span>;
        <span class="keywordtype">void</span> setPosition( <span class="keyword">const</span> <a class="code" href="classVector3.html">Vector3</a> &amp; newPosition );
    };
    ExampleClass exampleObject_;

    ...

    <a class="code" href="doc__watcher_8hpp.html#9f3f480240e132f58eba31aa81ea312a">MF_WATCH_REF</a>( <span class="stringliteral">"someValue"</span>, exampleObject_,
            ExampleClass::getPosition,
            ExampleClass::setPosition );
</pre></div><p>
For more details, see MF_WATCH. 
</div>
</div><p>
<a class="anchor" name="ga8606d3583be4a7bc1f86e58f5fd547a"></a><!-- doxytag: member="watcher.hpp::MF_WRITE_ACCESSOR" ref="ga8606d3583be4a7bc1f86e58f5fd547a" args="(TYPE, CLASS, METHOD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MF_WRITE_ACCESSOR          </td>
          <td>(</td>
          <td class="paramtype">TYPE,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">METHOD&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">static_cast&lt; TYPE (CLASS::*)() const &gt;( NULL ),                 \
    <span class="keyword">static_cast</span>&lt; <span class="keywordtype">void</span> (CLASS::*)(TYPE)   &gt;( &amp;CLASS::METHOD )
</pre></div>This macro is like MF_ACCESSORS except that the read accessor is NULL. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__WatcherModule.html#g429249ca76b29ff8fafe19ee6afdb56d">MF_ACCESSORS</a> </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g5a1bf922da7fcf5d62f3d450d53d4bfa"></a><!-- doxytag: member="watcher.hpp::addReferenceWatcher" ref="g5a1bf922da7fcf5d62f3d450d53d4bfa" args="(const char *path, OBJECT_TYPE &amp;rObject, const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(const RETURN_TYPE &amp;), const char *comment=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> addReferenceWatcher           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OBJECT_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RETURN_TYPE &amp;(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(OBJECT_TYPE::*)(const RETURN_TYPE &amp;)&nbsp;</td>
          <td class="paramname"> <em>setMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>comment</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to add a read/write watcher using a get and set methods. 
<p>

</div>
</div><p>
<a class="anchor" name="g87c3751dfee6e6aa4b5d2b0bf58b7404"></a><!-- doxytag: member="watcher.hpp::addReferenceWatcher" ref="g87c3751dfee6e6aa4b5d2b0bf58b7404" args="(const char *path, OBJECT_TYPE &amp;rObject, const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const, const char *comment=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> addReferenceWatcher           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OBJECT_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RETURN_TYPE &amp;(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>comment</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to add a read-only watcher using a get-accessor method. 
<p>

</div>
</div><p>
<a class="anchor" name="g3569563fee616fa3a122970783d25b1c"></a><!-- doxytag: member="watcher.hpp::addWatcher" ref="g3569563fee616fa3a122970783d25b1c" args="(const char *path, TYPE &amp;rValue, Watcher::Mode access=Watcher::WT_READ_WRITE, const char *comment=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> addWatcher           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWatcher.html#d89641290730ac55095dce0ef1f72510">Watcher::Mode</a>&nbsp;</td>
          <td class="paramname"> <em>access</em> = <code>Watcher::WT_READ_WRITE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>comment</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to add a watcher of a simple value. 
<p>

</div>
</div><p>
<a class="anchor" name="gbb7318937b0d2130eb750685026d7165"></a><!-- doxytag: member="watcher.hpp::addWatcher" ref="gbb7318937b0d2130eb750685026d7165" args="(const char *path, RETURN_TYPE(*getFunction)(), void(*setFunction)(RETURN_TYPE)=NULL, const char *comment=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> addWatcher           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RETURN_TYPE(*)()&nbsp;</td>
          <td class="paramname"> <em>getFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(RETURN_TYPE)&nbsp;</td>
          <td class="paramname"> <em>setFunction</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>comment</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to add a watcher of a function value. 
<p>

</div>
</div><p>
<a class="anchor" name="ga8e91a6e82eb77cc71e69f7f3c65dd22"></a><!-- doxytag: member="watcher.hpp::addWatcher" ref="ga8e91a6e82eb77cc71e69f7f3c65dd22" args="(const char *path, OBJECT_TYPE &amp;rObject, RETURN_TYPE(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(RETURN_TYPE), const char *comment=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> addWatcher           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OBJECT_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RETURN_TYPE(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(OBJECT_TYPE::*)(RETURN_TYPE)&nbsp;</td>
          <td class="paramname"> <em>setMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>comment</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to add a read/write watcher using a get and set accessor methods. 
<p>

</div>
</div><p>
<a class="anchor" name="gab9285936cb06ad409ef9543005438df"></a><!-- doxytag: member="watcher.hpp::addWatcher" ref="gab9285936cb06ad409ef9543005438df" args="(const char *path, OBJECT_TYPE &amp;rObject, RETURN_TYPE(OBJECT_TYPE::*getMethod)() const, const char *comment=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> addWatcher           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OBJECT_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RETURN_TYPE(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>comment</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to add a read-only watcher using a get-accessor method. 
<p>

</div>
</div><p>
<a class="anchor" name="g0b506ede5f4704718a6c511c5db37875"></a><!-- doxytag: member="watcher.hpp::makeNonRefWatcher" ref="g0b506ede5f4704718a6c511c5db37875" args="(OBJECT_TYPE &amp;rObject, RETURN_TYPE(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(RETURN_TYPE), const char *comment=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> makeNonRefWatcher           </td>
          <td>(</td>
          <td class="paramtype">OBJECT_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RETURN_TYPE(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(OBJECT_TYPE::*)(RETURN_TYPE)&nbsp;</td>
          <td class="paramname"> <em>setMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>comment</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to create a read/write watcher using a get and set methods. 
<p>

</div>
</div><p>
<a class="anchor" name="g9656896abd78d02b7e2660ce68b0020e"></a><!-- doxytag: member="watcher.hpp::makeNonRefWatcher" ref="g9656896abd78d02b7e2660ce68b0020e" args="(RETURN_TYPE(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(RETURN_TYPE), const char *comment=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> makeNonRefWatcher           </td>
          <td>(</td>
          <td class="paramtype">RETURN_TYPE(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(OBJECT_TYPE::*)(RETURN_TYPE)&nbsp;</td>
          <td class="paramname"> <em>setMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>comment</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to create a read/write watcher using a get and set methods. 
<p>

</div>
</div><p>
<a class="anchor" name="g083d64201e10ebd6d70fa64317693509"></a><!-- doxytag: member="watcher.hpp::makeWatcher" ref="g083d64201e10ebd6d70fa64317693509" args="(OBJECT_TYPE &amp;rObject, RETURN_TYPE(OBJECT_TYPE::*getMethod)() const )" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> makeWatcher           </td>
          <td>(</td>
          <td class="paramtype">OBJECT_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RETURN_TYPE(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to create a read-only watcher using a get method. 
<p>

</div>
</div><p>
<a class="anchor" name="g039ec5fb04c70687d588e712c4bd67ee"></a><!-- doxytag: member="watcher.hpp::makeWatcher" ref="g039ec5fb04c70687d588e712c4bd67ee" args="(OBJECT_TYPE &amp;rObject, const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(const RETURN_TYPE &amp;))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> makeWatcher           </td>
          <td>(</td>
          <td class="paramtype">OBJECT_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RETURN_TYPE &amp;(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(OBJECT_TYPE::*)(const RETURN_TYPE &amp;)&nbsp;</td>
          <td class="paramname"> <em>setMethod</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to create a read/write watcher using a get and set methods. 
<p>

</div>
</div><p>
<a class="anchor" name="g79011afb5d44b9c7b2cbce6cf7932acd"></a><!-- doxytag: member="watcher.hpp::makeWatcher" ref="g79011afb5d44b9c7b2cbce6cf7932acd" args="(OBJECT_TYPE &amp;rObject, const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const )" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> makeWatcher           </td>
          <td>(</td>
          <td class="paramtype">OBJECT_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RETURN_TYPE &amp;(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to create a read-only watcher using a get method. 
<p>

</div>
</div><p>
<a class="anchor" name="g1ff9b571f4be01c90fe05117fca721fe"></a><!-- doxytag: member="watcher.hpp::makeWatcher" ref="g1ff9b571f4be01c90fe05117fca721fe" args="(RETURN_TYPE(OBJECT_TYPE::*getMethod)() const )" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> makeWatcher           </td>
          <td>(</td>
          <td class="paramtype">RETURN_TYPE(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to create a read-only watcher using a get method. 
<p>

</div>
</div><p>
<a class="anchor" name="g90c396ac7763a388c4e9ab46bca4771d"></a><!-- doxytag: member="watcher.hpp::makeWatcher" ref="g90c396ac7763a388c4e9ab46bca4771d" args="(RETURN_TYPE(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(RETURN_TYPE))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> makeWatcher           </td>
          <td>(</td>
          <td class="paramtype">RETURN_TYPE(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(OBJECT_TYPE::*)(RETURN_TYPE)&nbsp;</td>
          <td class="paramname"> <em>setMethod</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to create a read/write watcher using a get and set methods. 
<p>

</div>
</div><p>
<a class="anchor" name="g3633e592a744e05b3cec3d59da3f6b58"></a><!-- doxytag: member="watcher.hpp::makeWatcher" ref="g3633e592a744e05b3cec3d59da3f6b58" args="(const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const, void(OBJECT_TYPE::*setMethod)(const RETURN_TYPE &amp;))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> makeWatcher           </td>
          <td>(</td>
          <td class="paramtype">const RETURN_TYPE &amp;(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(OBJECT_TYPE::*)(const RETURN_TYPE &amp;)&nbsp;</td>
          <td class="paramname"> <em>setMethod</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to create a read/write watcher using a get and set methods. 
<p>

</div>
</div><p>
<a class="anchor" name="gb6603aeeb257208647b387aa49f58145"></a><!-- doxytag: member="watcher.hpp::makeWatcher" ref="gb6603aeeb257208647b387aa49f58145" args="(const RETURN_TYPE &amp;(OBJECT_TYPE::*getMethod)() const )" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RETURN_TYPE, class OBJECT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">WatcherPtr</a> makeWatcher           </td>
          <td>(</td>
          <td class="paramtype">const RETURN_TYPE &amp;(OBJECT_TYPE::*)() const &nbsp;</td>
          <td class="paramname"> <em>getMethod</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to create a read-only watcher using a get method. 
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="gc85e08aa4f1a823ddae78c265075ac2e"></a><!-- doxytag: member="watcher.hpp::WATCHER_SEPARATOR" ref="gc85e08aa4f1a823ddae78c265075ac2e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="group__WatcherModule.html#gc85e08aa4f1a823ddae78c265075ac2e">WATCHER_SEPARATOR</a> = '/'          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The character that separates values in a watcher path. 
<p>

</div>
</div><p>
<p class="copyrightFooter">Copyright 1999-2010 BigWorld Pty. Ltd. All rights reserved. Proprietary commercial in confidence.</p>

</body>
</html>
