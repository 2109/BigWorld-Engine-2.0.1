<html>
  <head><link rel="stylesheet" type="text/css" href="doxygen.css"></head>
  <body>
    <table width="100%" border="0" cellpadding="0" cellspacing="0">
        <tr> <td align=left style="background:#0F5286"> <img src="bwlogo_bluebkg.png"> </td> </tr>
    </table>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>ChunkSpace Class Reference</h1><!-- doxytag: class="ChunkSpace" --><!-- doxytag: inherits="ClientChunkSpace" -->This class defines a space and maintains the chunks that live in it.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;chunk_space.hpp&gt;</code>
<p>
Inheritance diagram for ChunkSpace:<p><center><img src="classChunkSpace__inherit__graph.png" border="0" usemap="#ChunkSpace__inherit__map" alt="Inheritance graph"></center>
<map name="ChunkSpace__inherit__map">
<area href="classClientChunkSpace.html" shape="rect" coords="5,5,149,32" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for ChunkSpace:<p><center><img src="classChunkSpace__coll__graph.png" border="0" usemap="#ChunkSpace__coll__map" alt="Collaboration graph"></center>
<map name="ChunkSpace__coll__map">
<area href="classClientChunkSpace.html" shape="rect" coords="141,112,285,139" alt="">
<area href="classSimpleMutex.html" shape="rect" coords="5,5,112,32" alt="">
<area href="classSmartPointer.html" shape="rect" coords="180,5,332,32" alt="">
<area href="classGeometryMappingFactory.html" shape="rect" coords="463,112,652,139" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classChunkSpace-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; <a class="el" href="classSpaceEntryID.html">SpaceEntryID</a>,<br>
 <a class="el" href="classGeometryMapping.html">GeometryMapping</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#6a8ef934d50e3a2122826970b75be567">GeometryMappings</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#d298715c804a03dde4494bcabe82ccf3">ChunkSpace</a> (<a class="el" href="enviro__minder_8hpp.html#be650f1ddbf40fb90da0178ce1f6e143">ChunkSpaceID</a> id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#d298715c804a03dde4494bcabe82ccf3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#3d8f3d9206ff9bb3c36b1e7d8c1216f7">~ChunkSpace</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#3d8f3d9206ff9bb3c36b1e7d8c1216f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#6d788398ab5638ab931889ef5d7451ef">hasChunksInMapping</a> (<a class="el" href="classGeometryMapping.html">GeometryMapping</a> *pMapping) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns whether any chunks in this space are associated with the given mapping.  <a href="#6d788398ab5638ab931889ef5d7451ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGeometryMapping.html">GeometryMapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#aa8c89f82c4287fc9d2c9a58e650811e">addMapping</a> (<a class="el" href="classSpaceEntryID.html">SpaceEntryID</a> mappingID, float *matrix, const std::string &amp;path, <a class="el" href="classSmartPointer.html">DataSectionPtr</a> pSettings=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method adds a mapping to this chunk space.  <a href="#aa8c89f82c4287fc9d2c9a58e650811e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#da23476eaf32ae933b9ad0c8bf279632">addMappingAsync</a> (<a class="el" href="classSpaceEntryID.html">SpaceEntryID</a> mappingID, float *matrix, const std::string &amp;path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method adds a mapping to this chunk space in a asynchronous way.  <a href="#da23476eaf32ae933b9ad0c8bf279632"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGeometryMapping.html">GeometryMapping</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#bd462f12eda74e1418634861aa5bd434">getMapping</a> (<a class="el" href="classSpaceEntryID.html">SpaceEntryID</a> mappingID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#3631c7df3e2132e2a71a82f0eed5257e">delMapping</a> (<a class="el" href="classSpaceEntryID.html">SpaceEntryID</a> mappingID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method removes the named mapping from this chunk space.  <a href="#3631c7df3e2132e2a71a82f0eed5257e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classChunkSpace.html#6a8ef934d50e3a2122826970b75be567">GeometryMappings</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#5d14e83c143c0d107cf45006b4d1ce24">getMappings</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#6dc966fa4e81c452860f93fc6bf00e7e">isMapped</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#648cd4260268b1cd060fdd7fd9bbc0b7">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear method.  <a href="#648cd4260268b1cd060fdd7fd9bbc0b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#3c3b88f7d4c0be258a6afa1c65487398">cleared</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classChunk.html">Chunk</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#c6b18b1ef10e7c5681b5d08e94d1d835">findChunkFromPoint</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;point)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This slow function is the last-resort way to find which chunk a given point belongs in.  <a href="#c6b18b1ef10e7c5681b5d08e94d1d835"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classChunk.html">Chunk</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#7f622daaca8fb22a896f8a072f5c0a20">findChunkFromPointExact</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;point)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns the exact chunk that contains a point If.  <a href="#7f622daaca8fb22a896f8a072f5c0a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Column *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#512e9911959674c9ec2002d4a2d6015d">column</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;point, bool canCreate=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the column at the given point, or NULL if it is out of range (or not created and canCreate is false).  <a href="#512e9911959674c9ec2002d4a2d6015d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#74e6b1debb19f93cf48c5e901f7838d4">collide</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;<a class="el" href="perlin__noise_8cpp.html#e14eb244407d3c32f2c387e98d3f0f65">start</a>, const <a class="el" href="classVector3.html">Vector3</a> &amp;end, <a class="el" href="classCollisionCallback.html">CollisionCallback</a> &amp;cc=<a class="el" href="chunk__space_8hpp.html#41db99dae83a379cc41c81d00b322e7e">CollisionCallback_s_default</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the chunk space collide wrapper method for colliding a ray with the chunk space.  <a href="#74e6b1debb19f93cf48c5e901f7838d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#64fad1fcc49059562d4e9bbc4bfc445c">collide</a> (const <a class="el" href="classWorldTriangle.html">WorldTriangle</a> &amp;<a class="el" href="perlin__noise_8cpp.html#e14eb244407d3c32f2c387e98d3f0f65">start</a>, const <a class="el" href="classVector3.html">Vector3</a> &amp;end, <a class="el" href="classCollisionCallback.html">CollisionCallback</a> &amp;cc=<a class="el" href="chunk__space_8hpp.html#41db99dae83a379cc41c81d00b322e7e">CollisionCallback_s_default</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the chunk space collide wrapper method for colliding a triangular prism.  <a href="#64fad1fcc49059562d4e9bbc4bfc445c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#5546f8e7ff2e63dadd83b39cfd4b30e9">setClosestPortalState</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;point, bool isPermissive, <a class="el" href="classWorldTriangle.html#488312f5af301fd949675f24ee93d79c">WorldTriangle::Flags</a> collisionFlags=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method attempts to set the collision state of the portal nearest to the input point.  <a href="#5546f8e7ff2e63dadd83b39cfd4b30e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#e26ab97bfa75c06286cabd8b4e8b3514">dumpDebug</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method dumps debug information about this space.  <a href="#e26ab97bfa75c06286cabd8b4e8b3514"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBoundingBox.html">BoundingBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#2d90c106dcc1029801f80f657d958d9c">gridBounds</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method calculates the bounding box of the space in world coords.  <a href="#2d90c106dcc1029801f80f657d958d9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classChunk.html">Chunk</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#88cd0209e3db35b133c4abbe96d4bf2c">guessChunk</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;point, bool lookInside=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method guesses which chunk to load based on an input point.  <a href="#88cd0209e3db35b133c4abbe96d4bf2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#f127d49934d075b3b506a0dcdecb3d42">unloadChunkBeforeBinding</a> (<a class="el" href="classChunk.html">Chunk</a> *pChunk)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method deletes a chunk that has just finished loading that is in a mapping that has been condemned by a 'delMapping' call, or is otherwise unwanted.  <a href="#f127d49934d075b3b506a0dcdecb3d42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#daf4cbff38d21aab95001e5d30a598a4">ignoreChunk</a> (<a class="el" href="classChunk.html">Chunk</a> *pChunk)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ignore a chunk as it's going to be disposed (unloaded).  <a href="#daf4cbff38d21aab95001e5d30a598a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#59614284d69c2f8854a856140dd0ea2b">noticeChunk</a> (<a class="el" href="classChunk.html">Chunk</a> *pChunk)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method notifies the chunk space that the given chunk is now bound and may be focussed.  <a href="#59614284d69c2f8854a856140dd0ea2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#8f0f33f219440a9cc0cf7951345132e9">closestUnloadedChunk</a> (float closest)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#9d410c7026162960a3424dc1ecca387b">closestUnloadedChunk</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#6e01f06f6f497139edfc0a0f51108398">loadNavmesh</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#f77b4513bed6b8567a65cc120499e413">validatePendingTask</a> (<a class="el" href="classBackgroundTask.html">BackgroundTask</a> *pTask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is called by the LoadMappingTask when it has finished background loading.  <a href="#f77b4513bed6b8567a65cc120499e413"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSmartPointer.html">Terrain::TerrainSettingsPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#bff0074a210bd209a288de5936047755">terrainSettings</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSpace.html#2afe57399d69c9c02d42c4b5b98b1cd0">pMappingFactory</a> (<a class="el" href="classGeometryMappingFactory.html">GeometryMappingFactory</a> *pFactory)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class defines a space and maintains the chunks that live in it. 
<p>
A space is a continuous three dimensional Cartesian medium. Each space is divided piecewise into chunks, which occupy the entire space but do not overlap. i.e. every point in the space is in exactly one chunk. Examples include: planets, parallel spaces, spacestations, 'detached' apartments / dungeon levels, etc. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="6a8ef934d50e3a2122826970b75be567"></a><!-- doxytag: member="ChunkSpace::GeometryMappings" ref="6a8ef934d50e3a2122826970b75be567" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt; <a class="el" href="classSpaceEntryID.html">SpaceEntryID</a>, <a class="el" href="classGeometryMapping.html">GeometryMapping</a> * &gt; <a class="el" href="classChunkSpace.html#6a8ef934d50e3a2122826970b75be567">ChunkSpace::GeometryMappings</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="d298715c804a03dde4494bcabe82ccf3"></a><!-- doxytag: member="ChunkSpace::ChunkSpace" ref="d298715c804a03dde4494bcabe82ccf3" args="(ChunkSpaceID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSpace::ChunkSpace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="enviro__minder_8hpp.html#be650f1ddbf40fb90da0178ce1f6e143">ChunkSpaceID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="3d8f3d9206ff9bb3c36b1e7d8c1216f7"></a><!-- doxytag: member="ChunkSpace::~ChunkSpace" ref="3d8f3d9206ff9bb3c36b1e7d8c1216f7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSpace::~ChunkSpace           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="aa8c89f82c4287fc9d2c9a58e650811e"></a><!-- doxytag: member="ChunkSpace::addMapping" ref="aa8c89f82c4287fc9d2c9a58e650811e" args="(SpaceEntryID mappingID, float *matrix, const std::string &amp;path, DataSectionPtr pSettings=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometryMapping.html">GeometryMapping</a> * ChunkSpace::addMapping           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSpaceEntryID.html">SpaceEntryID</a>&nbsp;</td>
          <td class="paramname"> <em>mappingID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSmartPointer.html">DataSectionPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pSettings</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method adds a mapping to this chunk space. 
<p>
It returns the mapping if the addition was successful. 
<p>
defined( MF_SERVER ) &amp;&amp; !defined( EDITOR_ENABLED ) 
</div>
</div><p>
<a class="anchor" name="da23476eaf32ae933b9ad0c8bf279632"></a><!-- doxytag: member="ChunkSpace::addMappingAsync" ref="da23476eaf32ae933b9ad0c8bf279632" args="(SpaceEntryID mappingID, float *matrix, const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSpace::addMappingAsync           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSpaceEntryID.html">SpaceEntryID</a>&nbsp;</td>
          <td class="paramname"> <em>mappingID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method adds a mapping to this chunk space in a asynchronous way. 
<p>
It does the IO tasks in a background thread before calling <a class="el" href="classChunkSpace.html#da23476eaf32ae933b9ad0c8bf279632">ChunkSpace::addMappingAsync</a>. 
</div>
</div><p>
<a class="anchor" name="648cd4260268b1cd060fdd7fd9bbc0b7"></a><!-- doxytag: member="ChunkSpace::clear" ref="648cd4260268b1cd060fdd7fd9bbc0b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSpace::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear method. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classBaseChunkSpace.html#07f6a3a71d6ccad750e0c783c625901f">BaseChunkSpace::clear</a> </dd></dl>

<p>
Reimplemented from <a class="el" href="classClientChunkSpace.html#d9ea4f0e0b2fbbdd198fba5ac2fa3c72">ClientChunkSpace</a>.
</div>
</div><p>
<a class="anchor" name="3c3b88f7d4c0be258a6afa1c65487398"></a><!-- doxytag: member="ChunkSpace::cleared" ref="3c3b88f7d4c0be258a6afa1c65487398" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChunkSpace::cleared           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9d410c7026162960a3424dc1ecca387b"></a><!-- doxytag: member="ChunkSpace::closestUnloadedChunk" ref="9d410c7026162960a3424dc1ecca387b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ChunkSpace::closestUnloadedChunk           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8f0f33f219440a9cc0cf7951345132e9"></a><!-- doxytag: member="ChunkSpace::closestUnloadedChunk" ref="8f0f33f219440a9cc0cf7951345132e9" args="(float closest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSpace::closestUnloadedChunk           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>closest</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="64fad1fcc49059562d4e9bbc4bfc445c"></a><!-- doxytag: member="ChunkSpace::collide" ref="64fad1fcc49059562d4e9bbc4bfc445c" args="(const WorldTriangle &amp;start, const Vector3 &amp;end, CollisionCallback &amp;cc=CollisionCallback_s_default) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ChunkSpace::collide           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWorldTriangle.html">WorldTriangle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCollisionCallback.html">CollisionCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cc</em> = <code><a class="el" href="chunk__space_8hpp.html#41db99dae83a379cc41c81d00b322e7e">CollisionCallback_s_default</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the chunk space collide wrapper method for colliding a triangular prism. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The start triangle for one end of the triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The end position of the first point on the triangle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cc</em>&nbsp;</td><td>The <a class="el" href="classCollisionCallback.html">CollisionCallback</a> class to use for notification.</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="chunk__space_8cpp.html#01b754ce188fa45837c0d464c369084f">ChunkSpace_collide</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="74e6b1debb19f93cf48c5e901f7838d4"></a><!-- doxytag: member="ChunkSpace::collide" ref="74e6b1debb19f93cf48c5e901f7838d4" args="(const Vector3 &amp;start, const Vector3 &amp;end, CollisionCallback &amp;cc=CollisionCallback_s_default) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ChunkSpace::collide           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCollisionCallback.html">CollisionCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cc</em> = <code><a class="el" href="chunk__space_8hpp.html#41db99dae83a379cc41c81d00b322e7e">CollisionCallback_s_default</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the chunk space collide wrapper method for colliding a ray with the chunk space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The start of the ray. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The end of the ray. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cc</em>&nbsp;</td><td>The callback object.</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="chunk__space_8cpp.html#01b754ce188fa45837c0d464c369084f">ChunkSpace_collide</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="512e9911959674c9ec2002d4a2d6015d"></a><!-- doxytag: member="ChunkSpace::column" ref="512e9911959674c9ec2002d4a2d6015d" args="(const Vector3 &amp;point, bool canCreate=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChunkSpace::Column * ChunkSpace::column           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>canCreate</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the column at the given point, or NULL if it is out of range (or not created and canCreate is false). 
<p>

</div>
</div><p>
<a class="anchor" name="3631c7df3e2132e2a71a82f0eed5257e"></a><!-- doxytag: member="ChunkSpace::delMapping" ref="3631c7df3e2132e2a71a82f0eed5257e" args="(SpaceEntryID mappingID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSpace::delMapping           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSpaceEntryID.html">SpaceEntryID</a>&nbsp;</td>
          <td class="paramname"> <em>mappingID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method removes the named mapping from this chunk space. 
<p>

</div>
</div><p>
<a class="anchor" name="e26ab97bfa75c06286cabd8b4e8b3514"></a><!-- doxytag: member="ChunkSpace::dumpDebug" ref="e26ab97bfa75c06286cabd8b4e8b3514" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSpace::dumpDebug           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method dumps debug information about this space. 
<p>

</div>
</div><p>
<a class="anchor" name="c6b18b1ef10e7c5681b5d08e94d1d835"></a><!-- doxytag: member="ChunkSpace::findChunkFromPoint" ref="c6b18b1ef10e7c5681b5d08e94d1d835" args="(const Vector3 &amp;point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunk.html">Chunk</a> * ChunkSpace::findChunkFromPoint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This slow function is the last-resort way to find which chunk a given point belongs in. 
<p>
The only thing that should use it every frame is the camera, as it is not subject to the same laws of physics as mortals are. 
</div>
</div><p>
<a class="anchor" name="7f622daaca8fb22a896f8a072f5c0a20"></a><!-- doxytag: member="ChunkSpace::findChunkFromPointExact" ref="7f622daaca8fb22a896f8a072f5c0a20" args="(const Vector3 &amp;point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunk.html">Chunk</a> * ChunkSpace::findChunkFromPointExact           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the exact chunk that contains a point If. 
<p>

</div>
</div><p>
<a class="anchor" name="bd462f12eda74e1418634861aa5bd434"></a><!-- doxytag: member="ChunkSpace::getMapping" ref="bd462f12eda74e1418634861aa5bd434" args="(SpaceEntryID mappingID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometryMapping.html">GeometryMapping</a> * ChunkSpace::getMapping           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSpaceEntryID.html">SpaceEntryID</a>&nbsp;</td>
          <td class="paramname"> <em>mappingID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5d14e83c143c0d107cf45006b4d1ce24"></a><!-- doxytag: member="ChunkSpace::getMappings" ref="5d14e83c143c0d107cf45006b4d1ce24" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classChunkSpace.html#6a8ef934d50e3a2122826970b75be567">GeometryMappings</a>&amp; ChunkSpace::getMappings           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2d90c106dcc1029801f80f657d958d9c"></a><!-- doxytag: member="ChunkSpace::gridBounds" ref="2d90c106dcc1029801f80f657d958d9c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundingBox.html">BoundingBox</a> ChunkSpace::gridBounds           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method calculates the bounding box of the space in world coords. 
<p>

</div>
</div><p>
<a class="anchor" name="88cd0209e3db35b133c4abbe96d4bf2c"></a><!-- doxytag: member="ChunkSpace::guessChunk" ref="88cd0209e3db35b133c4abbe96d4bf2c" args="(const Vector3 &amp;point, bool lookInside=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunk.html">Chunk</a> * ChunkSpace::guessChunk           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lookInside</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method guesses which chunk to load based on an input point. 
<p>
It returns an unloaded chunk, or NULL if none could be found. Note: the returned chunk notionally holds a reference to its mapping.<p>
If lookInside is false, then there must be no chunks in the space, however the chunk returned is not appointed (used for bootstrapping).<p>
If lookInside is true, then an inside chunk is returned in preference to an outside one, and there may be other chunks, and the chunk returned is not appointed (used for resolving extern portals). 
</div>
</div><p>
<a class="anchor" name="6d788398ab5638ab931889ef5d7451ef"></a><!-- doxytag: member="ChunkSpace::hasChunksInMapping" ref="6d788398ab5638ab931889ef5d7451ef" args="(GeometryMapping *pMapping) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChunkSpace::hasChunksInMapping           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometryMapping.html">GeometryMapping</a> *&nbsp;</td>
          <td class="paramname"> <em>pMapping</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns whether any chunks in this space are associated with the given mapping. 
<p>

</div>
</div><p>
<a class="anchor" name="daf4cbff38d21aab95001e5d30a598a4"></a><!-- doxytag: member="ChunkSpace::ignoreChunk" ref="daf4cbff38d21aab95001e5d30a598a4" args="(Chunk *pChunk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSpace::ignoreChunk           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classChunk.html">Chunk</a> *&nbsp;</td>
          <td class="paramname"> <em>pChunk</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ignore a chunk as it's going to be disposed (unloaded). 
<p>
Note that this method may delete columns from the focus grid, so the focus method must be called before anything robust accesses it. This is done from the 'camera' method in the chunk manager. 
</div>
</div><p>
<a class="anchor" name="6dc966fa4e81c452860f93fc6bf00e7e"></a><!-- doxytag: member="ChunkSpace::isMapped" ref="6dc966fa4e81c452860f93fc6bf00e7e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChunkSpace::isMapped           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Implements <a class="el" href="classBaseChunkSpace.html#fccf822f55b2fd03d065e6f62d77217f">BaseChunkSpace</a>.
</div>
</div><p>
<a class="anchor" name="6e01f06f6f497139edfc0a0f51108398"></a><!-- doxytag: member="ChunkSpace::loadNavmesh" ref="6e01f06f6f497139edfc0a0f51108398" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChunkSpace::loadNavmesh           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="59614284d69c2f8854a856140dd0ea2b"></a><!-- doxytag: member="ChunkSpace::noticeChunk" ref="59614284d69c2f8854a856140dd0ea2b" args="(Chunk *pChunk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSpace::noticeChunk           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classChunk.html">Chunk</a> *&nbsp;</td>
          <td class="paramname"> <em>pChunk</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method notifies the chunk space that the given chunk is now bound and may be focussed. 
<p>

</div>
</div><p>
<a class="anchor" name="2afe57399d69c9c02d42c4b5b98b1cd0"></a><!-- doxytag: member="ChunkSpace::pMappingFactory" ref="2afe57399d69c9c02d42c4b5b98b1cd0" args="(GeometryMappingFactory *pFactory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSpace::pMappingFactory           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometryMappingFactory.html">GeometryMappingFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>pFactory</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5546f8e7ff2e63dadd83b39cfd4b30e9"></a><!-- doxytag: member="ChunkSpace::setClosestPortalState" ref="5546f8e7ff2e63dadd83b39cfd4b30e9" args="(const Vector3 &amp;point, bool isPermissive, WorldTriangle::Flags collisionFlags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChunkSpace::setClosestPortalState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isPermissive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWorldTriangle.html#488312f5af301fd949675f24ee93d79c">WorldTriangle::Flags</a>&nbsp;</td>
          <td class="paramname"> <em>collisionFlags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method attempts to set the collision state of the portal nearest to the input point. 
<p>
Note that both sides of the portal are modified. 
</div>
</div><p>
<a class="anchor" name="bff0074a210bd209a288de5936047755"></a><!-- doxytag: member="ChunkSpace::terrainSettings" ref="bff0074a210bd209a288de5936047755" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">Terrain::TerrainSettingsPtr</a> ChunkSpace::terrainSettings           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f127d49934d075b3b506a0dcdecb3d42"></a><!-- doxytag: member="ChunkSpace::unloadChunkBeforeBinding" ref="f127d49934d075b3b506a0dcdecb3d42" args="(Chunk *pChunk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChunkSpace::unloadChunkBeforeBinding           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classChunk.html">Chunk</a> *&nbsp;</td>
          <td class="paramname"> <em>pChunk</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method deletes a chunk that has just finished loading that is in a mapping that has been condemned by a 'delMapping' call, or is otherwise unwanted. 
<p>
All bound chunks have already been taken care of, but chunks that were loading when the call was received are left dangling.<p>
This method takes all action necessary to discard such a chunk after the loading thread is done with it. If the chunk has ever been bound (even if it is currently unbound) then the normal 'unload' method should be used instead.<p>
If the chunk was in a condemned mapping, then it is safe to delete the chunk object after calling this function. 
</div>
</div><p>
<a class="anchor" name="f77b4513bed6b8567a65cc120499e413"></a><!-- doxytag: member="ChunkSpace::validatePendingTask" ref="f77b4513bed6b8567a65cc120499e413" args="(BackgroundTask *pTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChunkSpace::validatePendingTask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBackgroundTask.html">BackgroundTask</a> *&nbsp;</td>
          <td class="paramname"> <em>pTask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called by the LoadMappingTask when it has finished background loading. 
<p>
It checks whether it is still valid to proceed with mapping in geometry. It will not be valid if <a class="el" href="classChunkSpace.html#648cd4260268b1cd060fdd7fd9bbc0b7">ChunkSpace::clear</a> has been called in the meantime. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="chunk__space_8hpp.html">chunk_space.hpp</a><li><a class="el" href="chunk__space_8cpp.html">chunk_space.cpp</a></ul>
<p class="copyrightFooter">Copyright 1999-2010 BigWorld Pty. Ltd. All rights reserved. Proprietary commercial in confidence.</p>

</body>
</html>
