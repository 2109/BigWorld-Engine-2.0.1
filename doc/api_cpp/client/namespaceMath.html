<html>
  <head><link rel="stylesheet" type="text/css" href="doxygen.css"></head>
  <body>
    <table width="100%" border="0" cellpadding="0" cellspacing="0">
        <tr> <td align=left style="background:#0F5286"> <img src="bwlogo_bluebkg.png"> </td> </tr>
    </table>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<h1>Math Namespace Reference<br>
<small>
[<a class="el" href="group__Math.html">Math</a>]</small>
</h1>This namespace contains some math related functions.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1OrientedBBox.html">OrientedBBox</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class implements an oriented bounding box.  <a href="classMath_1_1OrientedBBox.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1Polygon.html">Polygon</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This templated class implements a simple polygon container.  <a href="classMath_1_1Polygon.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMath_1_1Polyhedron.html">Polyhedron</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is an interface for a generic polyhedron, and implements intersection tests against other polyhedra.  <a href="classMath_1_1Polyhedron.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classMath_1_1Polygon.html">Polygon</a>&lt; <a class="el" href="classVector2.html">Vector2</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMath.html#312766b53028dffa89ab53d44c503b0e">Polygon2D</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMath.html#8807829ab032e35144d35102022b4f0b">decay</a> (double srcValue, double dstValue, double halfLife, double deltaTime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function accepts a source and destination value and returns a value somewhere between the two, approaching from source to destination with increasing time.  <a href="#8807829ab032e35144d35102022b4f0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMath.html#90e9293d5930f97b571ca5b15d3af63e">decay</a> (float srcValue, float dstValue, float halfLife, float deltaTime)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#32d97098d6a9ad28455d233453dac5e6">clamp</a> (TYPE minValue, TYPE value, TYPE maxValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns the value clamped in between the minimum and maximum values supplied.  <a href="#32d97098d6a9ad28455d233453dac5e6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#c498b3ccaf49cd020d6acdf4c999eb74">clamp</a> (TYPE magnitude, TYPE value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns the value clamped in between the negative and positive of the magnitude supplied.  <a href="#c498b3ccaf49cd020d6acdf4c999eb74"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SRC, typename DST&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">DST&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#efa58c0029bb30b7e18251611a711502">lerp</a> (SRC const &amp;x, SRC const &amp;src_a, SRC const &amp;src_b, DST const &amp;dst_a, DST const &amp;dst_b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function linearly interpolates from a source range into a destination range.  <a href="#efa58c0029bb30b7e18251611a711502"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SRC, typename DST&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">DST&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#8667779ef7398230cdb97af7185013a1">safeLerp</a> (SRC const &amp;x, SRC const &amp;src_a, SRC const &amp;src_b, DST const &amp;dst_a, DST const &amp;dst_b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function also linearly interpolates from a source range into a destination range.  <a href="#8667779ef7398230cdb97af7185013a1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename TYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMath.html#a56a4c268c3b05c480586b608679e97c">lerp</a> (TYPE const &amp;t, TYPE const &amp;a, TYPE const &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linearly interpolate over an interval.  <a href="#a56a4c268c3b05c480586b608679e97c"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This namespace contains some math related functions. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="312766b53028dffa89ab53d44c503b0e"></a><!-- doxytag: member="Math::Polygon2D" ref="312766b53028dffa89ab53d44c503b0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classMath_1_1Polygon.html">Polygon</a>&lt;<a class="el" href="classVector2.html">Vector2</a>&gt; <a class="el" href="classMath_1_1Polygon.html">Math::Polygon2D</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="8807829ab032e35144d35102022b4f0b"></a><!-- doxytag: member="Math::decay" ref="8807829ab032e35144d35102022b4f0b" args="(double srcValue, double dstValue, double halfLife, double deltaTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Math::decay           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>srcValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dstValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>halfLife</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>deltaTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function accepts a source and destination value and returns a value somewhere between the two, approaching from source to destination with increasing time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>srcValue</em>&nbsp;</td><td>The value when deltaTime is 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dstValue</em>&nbsp;</td><td>The value approached as deltaTime gets large. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>halfLife</em>&nbsp;</td><td>Controls how quickly the value approaches the destination. It is the time taken for the value to cover half the remaining distance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deltaTime</em>&nbsp;</td><td>Indicates how much time has passed since the last update.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The decayed value between srcValue and dstValue. </dd></dl>

</div>
</div><p>
<a class="anchor" name="90e9293d5930f97b571ca5b15d3af63e"></a><!-- doxytag: member="Math::decay" ref="90e9293d5930f97b571ca5b15d3af63e" args="(float srcValue, float dstValue, float halfLife, float deltaTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Math::decay           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>srcValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>dstValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>halfLife</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>deltaTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="namespaceMath.html#8807829ab032e35144d35102022b4f0b">decay</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="32d97098d6a9ad28455d233453dac5e6"></a><!-- doxytag: member="Math::clamp" ref="32d97098d6a9ad28455d233453dac5e6" args="(TYPE minValue, TYPE value, TYPE maxValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE Math::clamp           </td>
          <td>(</td>
          <td class="paramtype">TYPE&nbsp;</td>
          <td class="paramname"> <em>minValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE&nbsp;</td>
          <td class="paramname"> <em>maxValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the value clamped in between the minimum and maximum values supplied. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minValue</em>&nbsp;</td><td>The minimum the result can be. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to clamp. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxValue</em>&nbsp;</td><td>The maximum the result can be.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value clamped between the minimum and maximum values. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c498b3ccaf49cd020d6acdf4c999eb74"></a><!-- doxytag: member="Math::clamp" ref="c498b3ccaf49cd020d6acdf4c999eb74" args="(TYPE magnitude, TYPE value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE Math::clamp           </td>
          <td>(</td>
          <td class="paramtype">TYPE&nbsp;</td>
          <td class="paramname"> <em>magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the value clamped in between the negative and positive of the magnitude supplied. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>magnitude</em>&nbsp;</td><td>Specifies the magnitude of the range to clamp to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to clamp.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value clamped in the range [-magnitude, magnitude]. </dd></dl>

</div>
</div><p>
<a class="anchor" name="efa58c0029bb30b7e18251611a711502"></a><!-- doxytag: member="Math::lerp" ref="efa58c0029bb30b7e18251611a711502" args="(SRC const &amp;x, SRC const &amp;src_a, SRC const &amp;src_b, DST const &amp;dst_a, DST const &amp;dst_b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SRC, typename DST&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DST Math::lerp           </td>
          <td>(</td>
          <td class="paramtype">SRC const &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SRC const &amp;&nbsp;</td>
          <td class="paramname"> <em>src_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SRC const &amp;&nbsp;</td>
          <td class="paramname"> <em>src_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DST const &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DST const &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function linearly interpolates from a source range into a destination range. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The value to interpolate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_a</em>&nbsp;</td><td>The source range minimum. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_b</em>&nbsp;</td><td>The source range maximum. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_a</em>&nbsp;</td><td>The destination range minimum. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_b</em>&nbsp;</td><td>The destination range maximum.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The interpolated value of x in the source range in the destination range. For example if x = src_a then the result is dst_b, if x is the mid point of [src_a, src_b] then the result is the mid point of [dst_a, dst_b]. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8667779ef7398230cdb97af7185013a1"></a><!-- doxytag: member="Math::safeLerp" ref="8667779ef7398230cdb97af7185013a1" args="(SRC const &amp;x, SRC const &amp;src_a, SRC const &amp;src_b, DST const &amp;dst_a, DST const &amp;dst_b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SRC, typename DST&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DST Math::safeLerp           </td>
          <td>(</td>
          <td class="paramtype">SRC const &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SRC const &amp;&nbsp;</td>
          <td class="paramname"> <em>src_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SRC const &amp;&nbsp;</td>
          <td class="paramname"> <em>src_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DST const &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DST const &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function also linearly interpolates from a source range into a destination range. 
<p>
It is slightly slower than lerp because it checks for the degenerate case in the source in which case it returns dsa_t.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The value to interpolate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_a</em>&nbsp;</td><td>The source range minimum. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_b</em>&nbsp;</td><td>The source range maximum. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_a</em>&nbsp;</td><td>The destination range minimum. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_b</em>&nbsp;</td><td>The destination range maximum.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The interpolated value of x in the source range in the destination range. For example if x = src_a then the result is dst_b, if x is the mid point of [src_a, src_b] then the result is the mid point of [dst_a, dst_b]. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a56a4c268c3b05c480586b608679e97c"></a><!-- doxytag: member="Math::lerp" ref="a56a4c268c3b05c480586b608679e97c" args="(TYPE const &amp;t, TYPE const &amp;a, TYPE const &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE Math::lerp           </td>
          <td>(</td>
          <td class="paramtype">TYPE const &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE const &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE const &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Linearly interpolate over an interval. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The t-value to interpolate with (typically in [0, 1]). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The lower value of the range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The upper value of the range.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a + t(b - a). </dd></dl>

</div>
</div><p>
<p class="copyrightFooter">Copyright 1999-2010 BigWorld Pty. Ltd. All rights reserved. Proprietary commercial in confidence.</p>

</body>
</html>
