<html>
  <head><link rel="stylesheet" type="text/css" href="doxygen.css"></head>
  <body>
    <table width="100%" border="0" cellpadding="0" cellspacing="0">
        <tr> <td align=left style="background:#0F5286"> <img src="bwlogo_bluebkg.png"> </td> </tr>
    </table>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>Matrix Class Reference<br>
<small>
[<a class="el" href="group__Math.html">Math</a>]</small>
</h1><!-- doxytag: class="Matrix" --><!-- doxytag: inherits="MatrixBase" -->This class provides a 4x4 matrix and associated operations.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;matrix.hpp&gt;</code>
<p>
Inheritance diagram for Matrix:<p><center><img src="classMatrix__inherit__graph.png" border="0" usemap="#Matrix__inherit__map" alt="Inheritance graph"></center>
<map name="Matrix__inherit__map">
<area href="classPyMatrix.html" shape="rect" coords="13,155,91,181" alt="">
<area href="structMatrixBase.html" shape="rect" coords="5,5,99,32" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for Matrix:<p><center><img src="classMatrix__coll__graph.png" border="0" usemap="#Matrix__coll__map" alt="Collaboration graph"></center>
<map name="Matrix__coll__map">
<area href="structMatrixBase.html" shape="rect" coords="5,5,99,32" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classMatrix-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#7fc3f5e4c81bd430e3ade6fc4294887c">Matrix</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This constructor creates a zero matrix.  <a href="#7fc3f5e4c81bd430e3ade6fc4294887c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#139c38c7603df65e1ac80a915428a36c">Matrix</a> (const <a class="el" href="classVector4.html">Vector4</a> &amp;v0, const <a class="el" href="classVector4.html">Vector4</a> &amp;v1, const <a class="el" href="classVector4.html">Vector4</a> &amp;v2, const <a class="el" href="classVector4.html">Vector4</a> &amp;v3)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This constructor creates a matrix with four Vector4s representing the rows of the matrix.  <a href="#139c38c7603df65e1ac80a915428a36c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#1e511272b6f11cac70d21f55fdfcb8d6">setZero</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to the zero matrix.  <a href="#1e511272b6f11cac70d21f55fdfcb8d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#aa7096902377d4540408c41d0d993b21">setIdentity</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to the identity matrix.  <a href="#aa7096902377d4540408c41d0d993b21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#6cbd359cc6faac2ef6aefe1828d5c6b2">setScale</a> (const float x, const float y, const float z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to a scaling matrix.  <a href="#6cbd359cc6faac2ef6aefe1828d5c6b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#af9a3437e0ab60401ccc67f3b148ffca">setScale</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to a scaling matrix.  <a href="#af9a3437e0ab60401ccc67f3b148ffca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#e2cc89753fe8036926a41e56cfb73fd5">setTranslate</a> (const float x, const float y, const float z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to be a translation matrix.  <a href="#e2cc89753fe8036926a41e56cfb73fd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#d68e0efa72f9f5d727da511bedfb1260">setTranslate</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to be a translation matrix.  <a href="#d68e0efa72f9f5d727da511bedfb1260"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#123031de990c701404d2fcbfaf499d3f">setRotateX</a> (const float angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to be a rotation matrix around the X axis.  <a href="#123031de990c701404d2fcbfaf499d3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#99545d72c11c7fb48aaba3bd447e41c9">setRotateY</a> (const float angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to be a rotation matrix around the Y axis.  <a href="#99545d72c11c7fb48aaba3bd447e41c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#54153028f8c482bb0a3eacc082427c80">setRotateZ</a> (const float angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to be a rotation matrix around the Z axis.  <a href="#54153028f8c482bb0a3eacc082427c80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#14844292d4f86e4e72ada2e29d5222fa">setRotate</a> (const <a class="el" href="classQuaternion.html">Quaternion</a> &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to be the rotation matrix equivalent to the input quaternion.  <a href="#14844292d4f86e4e72ada2e29d5222fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#b46406b9dc8cc8f171e20601225305bd">setRotate</a> (float yaw, float pitch, float roll)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to be the rotation matrix equivalent to the input yaw, pitch and roll values.  <a href="#b46406b9dc8cc8f171e20601225305bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#05c8171d56b3524a760cb31e16e10bc1">setRotateInverse</a> (float yaw, float pitch, float roll)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to be the inverse of the rotation matrix equivalent to the input yaw, pitch and roll values.  <a href="#05c8171d56b3524a760cb31e16e10bc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#7d6452f60f032f22fcbc61375b4f7e98">multiply</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;m1, const <a class="el" href="classMatrix.html">Matrix</a> &amp;m2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to the result of multiplying the two input matrices.  <a href="#7d6452f60f032f22fcbc61375b4f7e98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#0a4a6c6cb3a72efcad344aefe1780bf7">preMultiply</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;<a class="el" href="structMatrixBase.html#dcfe1d05e3c91d622cf66a1b12a8e29c">m</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to the result of multiply the input matrix by this matrix.  <a href="#0a4a6c6cb3a72efcad344aefe1780bf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a473deededf4a3f998f696ac189e3aa6">postMultiply</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;<a class="el" href="structMatrixBase.html#dcfe1d05e3c91d622cf66a1b12a8e29c">m</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to the result of multiply this matrix by the input matrix.  <a href="#a473deededf4a3f998f696ac189e3aa6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#bd1afc3b4a898accfc126fc7e35b90bf">invertOrthonormal</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;<a class="el" href="structMatrixBase.html#dcfe1d05e3c91d622cf66a1b12a8e29c">m</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method inverts the input matrix.  <a href="#bd1afc3b4a898accfc126fc7e35b90bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ed1c15a5de4b09be9cc21a70c944c2ec">invertOrthonormal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method inverts this matrix.  <a href="#ed1c15a5de4b09be9cc21a70c944c2ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#0d74bddd045b33394f09adfac11e6a7e">invert</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;<a class="el" href="structMatrixBase.html#dcfe1d05e3c91d622cf66a1b12a8e29c">m</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method inverts the input matrix.  <a href="#0d74bddd045b33394f09adfac11e6a7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#132ec8dcb87dfebaeb2907756fdf932d">invert</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method inverts this matrix.  <a href="#132ec8dcb87dfebaeb2907756fdf932d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#1e4d0a4fd69af271732dff1e11ddf696">getDeterminant</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the determinant of this matrix.  <a href="#1e4d0a4fd69af271732dff1e11ddf696"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#0eb1a764de42b3a552bf0cc12a628448">transpose</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;<a class="el" href="structMatrixBase.html#dcfe1d05e3c91d622cf66a1b12a8e29c">m</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method transposes the input matrix.  <a href="#0eb1a764de42b3a552bf0cc12a628448"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#f9587a9c714e21c4f6badb2db87c67c5">transpose</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method transposes this matrix.  <a href="#f9587a9c714e21c4f6badb2db87c67c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#2f8537a4450993a5eaa6135b52e5b131">lookAt</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;<a class="el" href="common__client__interface_8hpp.html#89962559f1858f4005037f8943c27601">position</a>, const <a class="el" href="classVector3.html">Vector3</a> &amp;direction, const <a class="el" href="classVector3.html">Vector3</a> &amp;up)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method creates a <em>look at</em> matrix from two directions and a position.  <a href="#2f8537a4450993a5eaa6135b52e5b131"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#2a8d38b3094d9155f2753dd865bd9962">operator()</a> (<a class="el" href="stdmf_8hpp.html#0e55fb2a49437eb666626ca96962e6a2">uint32</a> column, <a class="el" href="stdmf_8hpp.html#0e55fb2a49437eb666626ca96962e6a2">uint32</a> row)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method implements an operator that can be used to access individual elements of this matrix.  <a href="#2a8d38b3094d9155f2753dd865bd9962"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#5158a251c3ea109fff48ee4e32756cab">operator()</a> (<a class="el" href="stdmf_8hpp.html#0e55fb2a49437eb666626ca96962e6a2">uint32</a> column, <a class="el" href="stdmf_8hpp.html#0e55fb2a49437eb666626ca96962e6a2">uint32</a> row) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method implements an operator that can be used to access individual elements of this matrix.  <a href="#5158a251c3ea109fff48ee4e32756cab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classVector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#74071318eae8d4d43a3cd8c47d6fab1d">applyPoint</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;v2) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method multiplies the point represented by the input vector with this matrix.  <a href="#74071318eae8d4d43a3cd8c47d6fab1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#94ad2389879452d2280122893c26ffc1">applyPoint</a> (<a class="el" href="classVector3.html">Vector3</a> &amp;v1, const <a class="el" href="classVector3.html">Vector3</a> &amp;v2) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method multiplies the point represented by the input v2 with this matrix.  <a href="#94ad2389879452d2280122893c26ffc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#beca924b261b1373b65a3e1f18e83e35">applyPoint</a> (<a class="el" href="classVector4.html">Vector4</a> &amp;v1, const <a class="el" href="classVector3.html">Vector3</a> &amp;v2) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method applies this matrix to an input <a class="el" href="classVector3.html">Vector3</a> and produces a resulting <a class="el" href="classVector4.html">Vector4</a>.  <a href="#beca924b261b1373b65a3e1f18e83e35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#720d8e728a1b370b9b0e9bc6cb9231e4">applyPoint</a> (<a class="el" href="classVector4.html">Vector4</a> &amp;v1, const <a class="el" href="classVector4.html">Vector4</a> &amp;v2) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method applies this matrix to an input <a class="el" href="classVector4.html">Vector4</a> and produces a resulting <a class="el" href="classVector4.html">Vector4</a>.  <a href="#720d8e728a1b370b9b0e9bc6cb9231e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classVector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#8977e430322d9afa4645ba7373c34450">applyVector</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;v2) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method applies the transform to a vector.  <a href="#8977e430322d9afa4645ba7373c34450"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#2c7a2760b4b7ff71466c1f27b16ea0f2">applyVector</a> (<a class="el" href="classVector3.html">Vector3</a> &amp;v1, const <a class="el" href="classVector3.html">Vector3</a> &amp;v2) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method applies the transform to a vector.  <a href="#2c7a2760b4b7ff71466c1f27b16ea0f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#d57cbe15dcbc012137f935d6f6280e76">applyToUnitAxisVector</a> (int axis) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the vector that would result from applying the transform to the unit vector along the input axis.  <a href="#d57cbe15dcbc012137f935d6f6280e76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#c78c263bde82b615fcb74f4315f4124f">applyToOrigin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns the point that would result from applying the transform to the point at the origin.  <a href="#c78c263bde82b615fcb74f4315f4124f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#853b6e3765c317bf34ee90a0ae654ee0">operator[]</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns a row of the matrix as a <a class="el" href="classVector3.html">Vector3</a>.  <a href="#853b6e3765c317bf34ee90a0ae654ee0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#fa4b8507c5590b60842d865312e381ae">operator[]</a> (int i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns a row of the matrix as a <a class="el" href="classVector3.html">Vector3</a>.  <a href="#fa4b8507c5590b60842d865312e381ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#03a24f06186bb1617b04f00ac2c0788a">row</a> (int i, const <a class="el" href="classVector4.html">Vector4</a> &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets a row of the matrix as a <a class="el" href="classVector4.html">Vector4</a>.  <a href="#03a24f06186bb1617b04f00ac2c0788a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classVector4.html">Vector4</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#b1e54ec438009f6826d697b1fe10292b">row</a> (int i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns a row of the matrix as a <a class="el" href="classVector4.html">Vector4</a>.  <a href="#b1e54ec438009f6826d697b1fe10292b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classVector4.html">Vector4</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#dc6980fdf14ed83798e9b524f1872d9e">column</a> (int i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns a column of the matrix as a <a class="el" href="classVector4.html">Vector4</a>.  <a href="#dc6980fdf14ed83798e9b524f1872d9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#210104ced2d602ff806e4fba6931e976">column</a> (int i, const <a class="el" href="classVector4.html">Vector4</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets a column of the matrix as a <a class="el" href="classVector4.html">Vector4</a>.  <a href="#210104ced2d602ff806e4fba6931e976"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#d09ca64de6f65afde1c112ecb3428b33">preRotateX</a> (const float angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method pre multiplies this matrix by the matrix that rotates around the X axis by the input amount.  <a href="#d09ca64de6f65afde1c112ecb3428b33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ac9b168afba8165e381a108acaa38f22">preRotateY</a> (const float angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method pre multiplies this matrix by the matrix that rotates around the Y axis by the input amount.  <a href="#ac9b168afba8165e381a108acaa38f22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#7188da505fe342378b8ec32113b743d9">preRotateZ</a> (const float angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method pre multiplies this matrix by the matrix that rotates around the Y axis by the input amount.  <a href="#7188da505fe342378b8ec32113b743d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#81b0b4cd1fae5ee074defd5664fe3515">preTranslateBy</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method pre multiplies this matrix by the matrix that translates by the input amount.  <a href="#81b0b4cd1fae5ee074defd5664fe3515"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#d5b2208ccdbf660e09b9eff7aee20d95">postRotateX</a> (const float angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method post multiplies this matrix by the matrix that rotates around the X axis by the input amount.  <a href="#d5b2208ccdbf660e09b9eff7aee20d95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#9bb8848a7d40247c460dd829f0c85f31">postRotateY</a> (const float angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method post multiplies this matrix by the matrix that rotates around the Y axis by the input amount.  <a href="#9bb8848a7d40247c460dd829f0c85f31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#90a68767cb40ea92370a7142dd71efbd">postRotateZ</a> (const float angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method post multiplies this matrix by the matrix that rotates around the Z axis by the input amount.  <a href="#90a68767cb40ea92370a7142dd71efbd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#37b4600f2f74a4c16359e7fca320ada7">postTranslateBy</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method post multiplies this matrix by the matrix that translates by the input amount.  <a href="#37b4600f2f74a4c16359e7fca320ada7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#77932ff688a4980c46f994bdf9b90cfe">isMirrored</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method returns whether or not this matrix is mirrored.  <a href="#77932ff688a4980c46f994bdf9b90cfe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#c46cb3bce23c9947d9b2077bc87bdfdf">orthogonalProjection</a> (float w, float h, float zn, float zf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to a left-handed orthogonal projection matrix.  <a href="#c46cb3bce23c9947d9b2077bc87bdfdf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#88b3574c48b189f6029f85b0426da06c">perspectiveProjection</a> (float fov, float aspectRatio, float nearPlane, float farPlane)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets this matrix to a left-handed perspective projection matrix.  <a href="#88b3574c48b189f6029f85b0426da06c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#f8676d3282e3e5a240c8d9db024c5979">translation</a> (const <a class="el" href="classVector3.html">Vector3</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets the translation component of this matrix.  <a href="#f8676d3282e3e5a240c8d9db024c5979"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a70124c12f07ee03f87674ad2e2f1057">yaw</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the yaw of the rotation part of this matrix.  <a href="#a70124c12f07ee03f87674ad2e2f1057"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#e4804c9f6c232cfd0c4fefa64dd89643">pitch</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the pitch of the rotation part of this matrix.  <a href="#e4804c9f6c232cfd0c4fefa64dd89643"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#7966ec086758cf7136d34f4cf434d4a3">roll</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the roll of the rotation part of this matrix.  <a href="#7966ec086758cf7136d34f4cf434d4a3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="classMatrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#38518833cb8cc3d630e869c0f4d8f2b9">identity</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class provides a 4x4 matrix and associated operations. 
<p>
This class is most often used to represent a linear transformation from one 3D space to another. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="7fc3f5e4c81bd430e3ade6fc4294887c"></a><!-- doxytag: member="Matrix::Matrix" ref="7fc3f5e4c81bd430e3ade6fc4294887c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Matrix           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This constructor creates a zero matrix. 
<p>
That is, a matrix whose elements are all 0. 
</div>
</div><p>
<a class="anchor" name="139c38c7603df65e1ac80a915428a36c"></a><!-- doxytag: member="Matrix::Matrix" ref="139c38c7603df65e1ac80a915428a36c" args="(const Vector4 &amp;v0, const Vector4 &amp;v1, const Vector4 &amp;v2, const Vector4 &amp;v3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Matrix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vector4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vector4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vector4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vector4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This constructor creates a matrix with four Vector4s representing the rows of the matrix. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="720d8e728a1b370b9b0e9bc6cb9231e4"></a><!-- doxytag: member="Matrix::applyPoint" ref="720d8e728a1b370b9b0e9bc6cb9231e4" args="(Vector4 &amp;v1, const Vector4 &amp;v2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::applyPoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector4.html">Vector4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vector4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method applies this matrix to an input <a class="el" href="classVector4.html">Vector4</a> and produces a resulting <a class="el" href="classVector4.html">Vector4</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>The <a class="el" href="classVector4.html">Vector4</a> that will be set to the result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v2</em>&nbsp;</td><td>The <a class="el" href="classVector4.html">Vector4</a> that the matrix will be applied to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="beca924b261b1373b65a3e1f18e83e35"></a><!-- doxytag: member="Matrix::applyPoint" ref="beca924b261b1373b65a3e1f18e83e35" args="(Vector4 &amp;v1, const Vector3 &amp;v2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::applyPoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector4.html">Vector4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method applies this matrix to an input <a class="el" href="classVector3.html">Vector3</a> and produces a resulting <a class="el" href="classVector4.html">Vector4</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>The <a class="el" href="classVector4.html">Vector4</a> that will be set to the result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v2</em>&nbsp;</td><td>The <a class="el" href="classVector3.html">Vector3</a> that the matrix will be applied to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="94ad2389879452d2280122893c26ffc1"></a><!-- doxytag: member="Matrix::applyPoint" ref="94ad2389879452d2280122893c26ffc1" args="(Vector3 &amp;v1, const Vector3 &amp;v2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::applyPoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method multiplies the point represented by the input v2 with this matrix. 
<p>
The input vector is on the left of the multiplication. i.e. it produces vM, where v1 is the input point and M is this matrix. The resulting point is placed in v1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>The vector to place the resulting point in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v2</em>&nbsp;</td><td>The vector representing the point to be transformed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="74071318eae8d4d43a3cd8c47d6fab1d"></a><!-- doxytag: member="Matrix::applyPoint" ref="74071318eae8d4d43a3cd8c47d6fab1d" args="(const Vector3 &amp;v2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector3.html">Vector3</a> Matrix::applyPoint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method multiplies the point represented by the input vector with this matrix. 
<p>
The input vector is on the left of the multiplication. i.e. it produces vM, where v is the input point and M is this matrix.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The resulting point represented by a <a class="el" href="classVector3.html">Vector3</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c78c263bde82b615fcb74f4315f4124f"></a><!-- doxytag: member="Matrix::applyToOrigin" ref="c78c263bde82b615fcb74f4315f4124f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVector3.html">Vector3</a> &amp; Matrix::applyToOrigin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the point that would result from applying the transform to the point at the origin. 
<p>
This is the same as the translation part of the matrix. 
</div>
</div><p>
<a class="anchor" name="d57cbe15dcbc012137f935d6f6280e76"></a><!-- doxytag: member="Matrix::applyToUnitAxisVector" ref="d57cbe15dcbc012137f935d6f6280e76" args="(int axis) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVector3.html">Vector3</a> &amp; Matrix::applyToUnitAxisVector           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>axis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the vector that would result from applying the transform to the unit vector along the input axis. 
<p>
This corresponds to one of the columns of the matrix. 
</div>
</div><p>
<a class="anchor" name="2c7a2760b4b7ff71466c1f27b16ea0f2"></a><!-- doxytag: member="Matrix::applyVector" ref="2c7a2760b4b7ff71466c1f27b16ea0f2" args="(Vector3 &amp;v1, const Vector3 &amp;v2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::applyVector           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method applies the transform to a vector. 
<p>
It is the same as apply point except that it does not add the translation. The v1 is on the left of the multiplication. i.e. it produces vM, where M is this matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>The vector that is set to the resulting vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v2</em>&nbsp;</td><td>The vector that is to be transformed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classMatrix.html#74071318eae8d4d43a3cd8c47d6fab1d">applyPoint</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8977e430322d9afa4645ba7373c34450"></a><!-- doxytag: member="Matrix::applyVector" ref="8977e430322d9afa4645ba7373c34450" args="(const Vector3 &amp;v2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector3.html">Vector3</a> Matrix::applyVector           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method applies the transform to a vector. 
<p>
It is the same as apply point except that it does not add the translation. The v is on the left of the multiplication. i.e. it produces vM, where M is this matrix.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classMatrix.html#74071318eae8d4d43a3cd8c47d6fab1d">applyPoint</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="210104ced2d602ff806e4fba6931e976"></a><!-- doxytag: member="Matrix::column" ref="210104ced2d602ff806e4fba6931e976" args="(int i, const Vector4 &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::column           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vector4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets a column of the matrix as a <a class="el" href="classVector4.html">Vector4</a>. 
<p>
The columns are indexed from 0 to 3.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The index of the desired column. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The new value of the column. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dc6980fdf14ed83798e9b524f1872d9e"></a><!-- doxytag: member="Matrix::column" ref="dc6980fdf14ed83798e9b524f1872d9e" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector4.html">Vector4</a> Matrix::column           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns a column of the matrix as a <a class="el" href="classVector4.html">Vector4</a>. 
<p>
The columns are indexed from 0 to 3.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The index of the desired column.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The column with the input index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e4d0a4fd69af271732dff1e11ddf696"></a><!-- doxytag: member="Matrix::getDeterminant" ref="1e4d0a4fd69af271732dff1e11ddf696" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Matrix::getDeterminant           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the determinant of this matrix. 
<p>
For a non-scaling, non-skewing transform, this should be 1. 
</div>
</div><p>
<a class="anchor" name="132ec8dcb87dfebaeb2907756fdf932d"></a><!-- doxytag: member="Matrix::invert" ref="132ec8dcb87dfebaeb2907756fdf932d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::invert           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method inverts this matrix. 
<p>
This matrix is set to the result.<p>
<dl compact><dt><b>Warning:</b></dt><dd>The determinant of this matrix should not be 0. </dd></dl>

<p>
Reimplemented in <a class="el" href="classPyMatrix.html#45f707766d9401c44d5639f635f0c079">PyMatrix</a>.
</div>
</div><p>
<a class="anchor" name="0d74bddd045b33394f09adfac11e6a7e"></a><!-- doxytag: member="Matrix::invert" ref="0d74bddd045b33394f09adfac11e6a7e" args="(const Matrix &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::invert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method inverts the input matrix. 
<p>
This matrix is set to the result.<p>
<dl compact><dt><b>Warning:</b></dt><dd>The determinant of the input matrix should not be 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed1c15a5de4b09be9cc21a70c944c2ec"></a><!-- doxytag: member="Matrix::invertOrthonormal" ref="ed1c15a5de4b09be9cc21a70c944c2ec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::invertOrthonormal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method inverts this matrix. 
<p>
It only works on matrices that are orthonormal. That is, the axis vectors must be orthogonal and have unit length. This matrix is set to the result. 
</div>
</div><p>
<a class="anchor" name="bd1afc3b4a898accfc126fc7e35b90bf"></a><!-- doxytag: member="Matrix::invertOrthonormal" ref="bd1afc3b4a898accfc126fc7e35b90bf" args="(const Matrix &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::invertOrthonormal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method inverts the input matrix. 
<p>
It only works on matrices that are orthonormal. That is, the axis vectors must be orthogonal and have unit length. This matrix is set to the result. 
</div>
</div><p>
<a class="anchor" name="77932ff688a4980c46f994bdf9b90cfe"></a><!-- doxytag: member="Matrix::isMirrored" ref="77932ff688a4980c46f994bdf9b90cfe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::isMirrored           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns whether or not this matrix is mirrored. 
<p>
That is, whether applying this matrix to a coordinate system would change it from a left-handed coordinate system, to a right-handed coordinate system.<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if matrix is mirrored, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f8537a4450993a5eaa6135b52e5b131"></a><!-- doxytag: member="Matrix::lookAt" ref="2f8537a4450993a5eaa6135b52e5b131" args="(const Vector3 &amp;position, const Vector3 &amp;direction, const Vector3 &amp;up)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::lookAt           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>up</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method creates a <em>look at</em> matrix from two directions and a position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>The position to look from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>The direction to look. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>up</em>&nbsp;</td><td>The direction of <em>"up"</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7d6452f60f032f22fcbc61375b4f7e98"></a><!-- doxytag: member="Matrix::multiply" ref="7d6452f60f032f22fcbc61375b4f7e98" args="(const Matrix &amp;m1, const Matrix &amp;m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::multiply           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to the result of multiplying the two input matrices. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m1</em>&nbsp;</td><td>The left-hand side of the multiplication. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m2</em>&nbsp;</td><td>The right-hand side of the multiplication. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5158a251c3ea109fff48ee4e32756cab"></a><!-- doxytag: member="Matrix::operator()" ref="5158a251c3ea109fff48ee4e32756cab" args="(uint32 column, uint32 row) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Matrix::operator()           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdmf_8hpp.html#0e55fb2a49437eb666626ca96962e6a2">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdmf_8hpp.html#0e55fb2a49437eb666626ca96962e6a2">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>row</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method implements an operator that can be used to access individual elements of this matrix. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>column</em>&nbsp;</td><td>The column number of the desired element. This value must be in the range [0, 3]. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>row</em>&nbsp;</td><td>The row number of the desired element. This value must be in the range [0, 3].</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A copy of the specified element. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a8d38b3094d9155f2753dd865bd9962"></a><!-- doxytag: member="Matrix::operator()" ref="2a8d38b3094d9155f2753dd865bd9962" args="(uint32 column, uint32 row)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float &amp; Matrix::operator()           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdmf_8hpp.html#0e55fb2a49437eb666626ca96962e6a2">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdmf_8hpp.html#0e55fb2a49437eb666626ca96962e6a2">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>row</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method implements an operator that can be used to access individual elements of this matrix. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>column</em>&nbsp;</td><td>The column number of the desired element. This value must be in the range [0, 3]. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>row</em>&nbsp;</td><td>The row number of the desired element. This value must be in the range [0, 3].</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the specified element. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fa4b8507c5590b60842d865312e381ae"></a><!-- doxytag: member="Matrix::operator[]" ref="fa4b8507c5590b60842d865312e381ae" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVector3.html">Vector3</a> &amp; Matrix::operator[]           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns a row of the matrix as a <a class="el" href="classVector3.html">Vector3</a>. 
<p>
The rows are indexed from 0 to 3.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The index of the desired row.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The row with the input index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="853b6e3765c317bf34ee90a0ae654ee0"></a><!-- doxytag: member="Matrix::operator[]" ref="853b6e3765c317bf34ee90a0ae654ee0" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector3.html">Vector3</a> &amp; Matrix::operator[]           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns a row of the matrix as a <a class="el" href="classVector3.html">Vector3</a>. 
<p>
The rows are indexed from 0 to 3.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The index of the desired row.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The row with the input index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c46cb3bce23c9947d9b2077bc87bdfdf"></a><!-- doxytag: member="Matrix::orthogonalProjection" ref="c46cb3bce23c9947d9b2077bc87bdfdf" args="(float w, float h, float zn, float zf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::orthogonalProjection           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>zn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>zf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to a left-handed orthogonal projection matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="88b3574c48b189f6029f85b0426da06c"></a><!-- doxytag: member="Matrix::perspectiveProjection" ref="88b3574c48b189f6029f85b0426da06c" args="(float fov, float aspectRatio, float nearPlane, float farPlane)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::perspectiveProjection           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>aspectRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>farPlane</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to a left-handed perspective projection matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="e4804c9f6c232cfd0c4fefa64dd89643"></a><!-- doxytag: member="Matrix::pitch" ref="e4804c9f6c232cfd0c4fefa64dd89643" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Matrix::pitch           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the pitch of the rotation part of this matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="a473deededf4a3f998f696ac189e3aa6"></a><!-- doxytag: member="Matrix::postMultiply" ref="a473deededf4a3f998f696ac189e3aa6" args="(const Matrix &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::postMultiply           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to the result of multiply this matrix by the input matrix. 
<p>
The input matrix is on the right-hand side of the multiplication and this matrix is on the left.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The matrix to post-multiply this matrix by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d5b2208ccdbf660e09b9eff7aee20d95"></a><!-- doxytag: member="Matrix::postRotateX" ref="d5b2208ccdbf660e09b9eff7aee20d95" args="(const float angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::postRotateX           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method post multiplies this matrix by the matrix that rotates around the X axis by the input amount. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>The angle in radians to rotate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9bb8848a7d40247c460dd829f0c85f31"></a><!-- doxytag: member="Matrix::postRotateY" ref="9bb8848a7d40247c460dd829f0c85f31" args="(const float angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::postRotateY           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method post multiplies this matrix by the matrix that rotates around the Y axis by the input amount. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>The angle in radians to rotate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="90a68767cb40ea92370a7142dd71efbd"></a><!-- doxytag: member="Matrix::postRotateZ" ref="90a68767cb40ea92370a7142dd71efbd" args="(const float angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::postRotateZ           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method post multiplies this matrix by the matrix that rotates around the Z axis by the input amount. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>The angle in radians to rotate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="37b4600f2f74a4c16359e7fca320ada7"></a><!-- doxytag: member="Matrix::postTranslateBy" ref="37b4600f2f74a4c16359e7fca320ada7" args="(const Vector3 &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::postTranslateBy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method post multiplies this matrix by the matrix that translates by the input amount. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The amount to translate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0a4a6c6cb3a72efcad344aefe1780bf7"></a><!-- doxytag: member="Matrix::preMultiply" ref="0a4a6c6cb3a72efcad344aefe1780bf7" args="(const Matrix &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::preMultiply           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to the result of multiply the input matrix by this matrix. 
<p>
The input matrix is on the left-hand side of the multiplication and this matrix is on the right.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The matrix to pre-multiply this matrix by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d09ca64de6f65afde1c112ecb3428b33"></a><!-- doxytag: member="Matrix::preRotateX" ref="d09ca64de6f65afde1c112ecb3428b33" args="(const float angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::preRotateX           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method pre multiplies this matrix by the matrix that rotates around the X axis by the input amount. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>The angle in radians to rotate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ac9b168afba8165e381a108acaa38f22"></a><!-- doxytag: member="Matrix::preRotateY" ref="ac9b168afba8165e381a108acaa38f22" args="(const float angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::preRotateY           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method pre multiplies this matrix by the matrix that rotates around the Y axis by the input amount. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>The angle in radians to rotate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7188da505fe342378b8ec32113b743d9"></a><!-- doxytag: member="Matrix::preRotateZ" ref="7188da505fe342378b8ec32113b743d9" args="(const float angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::preRotateZ           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method pre multiplies this matrix by the matrix that rotates around the Y axis by the input amount. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>The angle in radians to rotate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="81b0b4cd1fae5ee074defd5664fe3515"></a><!-- doxytag: member="Matrix::preTranslateBy" ref="81b0b4cd1fae5ee074defd5664fe3515" args="(const Vector3 &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::preTranslateBy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method pre multiplies this matrix by the matrix that translates by the input amount. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The amount to translate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7966ec086758cf7136d34f4cf434d4a3"></a><!-- doxytag: member="Matrix::roll" ref="7966ec086758cf7136d34f4cf434d4a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Matrix::roll           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the roll of the rotation part of this matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="b1e54ec438009f6826d697b1fe10292b"></a><!-- doxytag: member="Matrix::row" ref="b1e54ec438009f6826d697b1fe10292b" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVector4.html">Vector4</a> &amp; Matrix::row           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns a row of the matrix as a <a class="el" href="classVector4.html">Vector4</a>. 
<p>
The rows are indexed from 0 to 3.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The index of the desired row.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The row with the input index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="03a24f06186bb1617b04f00ac2c0788a"></a><!-- doxytag: member="Matrix::row" ref="03a24f06186bb1617b04f00ac2c0788a" args="(int i, const Vector4 &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::row           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector4.html">Vector4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets a row of the matrix as a <a class="el" href="classVector4.html">Vector4</a>. 
<p>
The rows are indexed from 0 to 3.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The index of the desired row. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The values to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="aa7096902377d4540408c41d0d993b21"></a><!-- doxytag: member="Matrix::setIdentity" ref="aa7096902377d4540408c41d0d993b21" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setIdentity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to the identity matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="b46406b9dc8cc8f171e20601225305bd"></a><!-- doxytag: member="Matrix::setRotate" ref="b46406b9dc8cc8f171e20601225305bd" args="(float yaw, float pitch, float roll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setRotate           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>yaw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>roll</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to be the rotation matrix equivalent to the input yaw, pitch and roll values. 
<p>
The order of application is: roll, then pitch, then yaw. 
</div>
</div><p>
<a class="anchor" name="14844292d4f86e4e72ada2e29d5222fa"></a><!-- doxytag: member="Matrix::setRotate" ref="14844292d4f86e4e72ada2e29d5222fa" args="(const Quaternion &amp;q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setRotate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQuaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to be the rotation matrix equivalent to the input quaternion. 
<p>

</div>
</div><p>
<a class="anchor" name="05c8171d56b3524a760cb31e16e10bc1"></a><!-- doxytag: member="Matrix::setRotateInverse" ref="05c8171d56b3524a760cb31e16e10bc1" args="(float yaw, float pitch, float roll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setRotateInverse           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>yaw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>roll</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to be the inverse of the rotation matrix equivalent to the input yaw, pitch and roll values. 
<p>
The order of application in the non-inverted matrix is: roll, then pitch, then yaw. 
</div>
</div><p>
<a class="anchor" name="123031de990c701404d2fcbfaf499d3f"></a><!-- doxytag: member="Matrix::setRotateX" ref="123031de990c701404d2fcbfaf499d3f" args="(const float angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setRotateX           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to be a rotation matrix around the X axis. 
<p>
A positive value rotates the Y axis toward the Z axis.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>The angle in radians to rotate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="99545d72c11c7fb48aaba3bd447e41c9"></a><!-- doxytag: member="Matrix::setRotateY" ref="99545d72c11c7fb48aaba3bd447e41c9" args="(const float angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setRotateY           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to be a rotation matrix around the Y axis. 
<p>
A positive value rotates the Z axis toward the X axis.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>The angle in radians to rotate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="54153028f8c482bb0a3eacc082427c80"></a><!-- doxytag: member="Matrix::setRotateZ" ref="54153028f8c482bb0a3eacc082427c80" args="(const float angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setRotateZ           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to be a rotation matrix around the Z axis. 
<p>
A positive rotates the X axis toward the Y axis.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>The angle in radians to rotate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="af9a3437e0ab60401ccc67f3b148ffca"></a><!-- doxytag: member="Matrix::setScale" ref="af9a3437e0ab60401ccc67f3b148ffca" args="(const Vector3 &amp;scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setScale           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scale</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to a scaling matrix. 
<p>
It does not contain any rotation and translation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>The amount to scale in each coordinate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6cbd359cc6faac2ef6aefe1828d5c6b2"></a><!-- doxytag: member="Matrix::setScale" ref="6cbd359cc6faac2ef6aefe1828d5c6b2" args="(const float x, const float y, const float z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setScale           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to a scaling matrix. 
<p>
It does not contain any rotation and translation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The amount to scale the x-coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The amount to scale the y-coordinate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>The amount to scale the z-coordinate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d68e0efa72f9f5d727da511bedfb1260"></a><!-- doxytag: member="Matrix::setTranslate" ref="d68e0efa72f9f5d727da511bedfb1260" args="(const Vector3 &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setTranslate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to be a translation matrix. 
<p>
It contains no rotation or scaling.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The amount to translate by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e2cc89753fe8036926a41e56cfb73fd5"></a><!-- doxytag: member="Matrix::setTranslate" ref="e2cc89753fe8036926a41e56cfb73fd5" args="(const float x, const float y, const float z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setTranslate           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to be a translation matrix. 
<p>
It contains no rotation or scaling.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The amount to translate along the x-axis. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The amount to translate along the y-axis. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>The amount to translate along the z-axis. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1e511272b6f11cac70d21f55fdfcb8d6"></a><!-- doxytag: member="Matrix::setZero" ref="1e511272b6f11cac70d21f55fdfcb8d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setZero           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets this matrix to the zero matrix. 
<p>
The zero matrix is the matrix whose elements are all 0. 
</div>
</div><p>
<a class="anchor" name="f8676d3282e3e5a240c8d9db024c5979"></a><!-- doxytag: member="Matrix::translation" ref="f8676d3282e3e5a240c8d9db024c5979" args="(const Vector3 &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::translation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method sets the translation component of this matrix. 
<p>

<p>
Reimplemented in <a class="el" href="classPyMatrix.html#ece4eb0dc6dfdb475e938d796a03c831">PyMatrix</a>.
</div>
</div><p>
<a class="anchor" name="f9587a9c714e21c4f6badb2db87c67c5"></a><!-- doxytag: member="Matrix::transpose" ref="f9587a9c714e21c4f6badb2db87c67c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::transpose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method transposes this matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="0eb1a764de42b3a552bf0cc12a628448"></a><!-- doxytag: member="Matrix::transpose" ref="0eb1a764de42b3a552bf0cc12a628448" args="(const Matrix &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::transpose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method transposes the input matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="a70124c12f07ee03f87674ad2e2f1057"></a><!-- doxytag: member="Matrix::yaw" ref="a70124c12f07ee03f87674ad2e2f1057" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Matrix::yaw           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the yaw of the rotation part of this matrix. 
<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="38518833cb8cc3d630e869c0f4d8f2b9"></a><!-- doxytag: member="Matrix::identity" ref="38518833cb8cc3d630e869c0f4d8f2b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a> <a class="el" href="classMatrix.html#38518833cb8cc3d630e869c0f4d8f2b9">Matrix::identity</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="matrix_8hpp.html">matrix.hpp</a><li><a class="el" href="matrix_8cpp.html">matrix.cpp</a><li><a class="el" href="matrix_8ipp.html">matrix.ipp</a></ul>
<p class="copyrightFooter">Copyright 1999-2010 BigWorld Pty. Ltd. All rights reserved. Proprietary commercial in confidence.</p>

</body>
</html>
